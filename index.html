<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Survey Builder</title>
    <link rel="icon" type="image/svg+xml" href="./assets/logo.svg" />
    <style>
      :root {
        color-scheme: light;
        --bg: #edf2fb;
        --surface: #ffffff;
        --accent: #6c7ae0;
        --accent-strong: #5661c5;
        --text: #1f2a44;
        --muted: #7c88b0;
        --border: rgba(31, 42, 68, 0.12);
        --soft: rgba(108, 122, 224, 0.08);
        font-family: "Inter", "PingFang SC", "Microsoft YaHei", system-ui,
          -apple-system, BlinkMacSystemFont, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #fdf2ff 0%, #edf4ff 40%, var(--bg) 100%);
        padding: 48px 24px 64px;
        color: var(--text);
      }

      .page {
        max-width: 1180px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 32px;
      }

      .qr-card {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(220px, 0.8fr);
        gap: 32px;
        background: var(--surface);
        border-radius: 28px;
        padding: 32px 40px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.08);
        align-items: center;
      }

      .qr-content h2 {
        margin: 8px 0 12px;
      }

      .qr-helper {
        margin: 0 0 18px;
        color: var(--muted);
        line-height: 1.6;
      }

      .qr-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .qr-form label {
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .qr-form input {
        border-radius: 14px;
        border: 1px solid var(--border);
        padding: 12px 14px;
        font-size: 0.95rem;
      }

      .qr-form input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--soft);
      }

      .qr-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .qr-preview {
        border-radius: 24px;
        border: 1px dashed rgba(108, 122, 224, 0.25);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        justify-content: center;
        background: rgba(247, 249, 255, 0.9);
      }

      .qr-canvas {
        width: 180px;
        height: 180px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .qr-canvas img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .qr-note {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
        text-align: center;
      }

      .page-tabs {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 20px;
        padding: 6px;
        border: 1px solid var(--border);
      }

      .tab-btn {
        flex: 1;
        border: none;
        background: transparent;
        color: var(--muted);
        font-weight: 600;
        padding: 12px 20px;
        border-radius: 16px;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .tab-btn.active {
        background: var(--text);
        color: white;
      }

      .hero {
        display: flex;
        justify-content: space-between;
        gap: 24px;
        align-items: center;
        background: var(--surface);
        border-radius: 28px;
        padding: 32px 40px;
        box-shadow: 0 25px 60px rgba(31, 42, 68, 0.12);
        border: 1px solid var(--border);
      }

      .hero-actions {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: flex-end;
      }

      .hero-brand {
        display: flex;
        align-items: center;
        gap: 24px;
        flex: 1;
      }

      .hero-logo {
        width: 110px;
        max-height: 110px;
        object-fit: contain;
      }

      .hero-copy {
        flex: 1;
      }

      .hero h1 {
        margin: 6px 0 12px;
        font-size: 2rem;
        letter-spacing: -0.02em;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        max-width: 560px;
        line-height: 1.6;
      }

      .eyebrow {
        font-size: 0.85rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--accent-strong);
      }

      .toggle {
        background: rgba(108, 122, 224, 0.1);
        color: var(--accent-strong);
        border: none;
        padding: 12px 20px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
        white-space: nowrap;
      }

      .toggle:hover {
        transform: translateY(-1px);
        background: rgba(108, 122, 224, 0.16);
      }

      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 24px;
      }

      .admin-mode .layout {
        grid-template-columns: minmax(0, 1.1fr) minmax(320px, 0.9fr);
      }

      .panel {
        background: var(--surface);
        border-radius: 28px;
        padding: 32px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.08);
        display: flex;
        flex-direction: column;
        gap: 24px;
        overflow: visible;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: center;
      }

      .panel-actions {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .panel h2 {
        margin: 6px 0 0;
      }

      .ghost {
        background: transparent;
        border: 1px dashed var(--accent);
        color: var(--accent-strong);
        padding: 10px 18px;
        border-radius: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: border 0.2s ease, color 0.2s ease;
      }

      .ghost:hover {
        border-color: var(--accent-strong);
        color: var(--accent-strong);
      }

      .ghost-small {
        padding: 8px 14px;
        border-radius: 12px;
      }

      .scroll-control {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 220px;
      }

      .editor-controls {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .scroll-label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .scroll-range {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--accent) 0%, rgba(108, 122, 224, 0.35) 100%);
        position: relative;
        cursor: pointer;
      }

      .scroll-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--surface);
        border: 2px solid var(--accent);
        box-shadow: 0 4px 15px rgba(31, 42, 68, 0.2);
      }

      .scroll-range::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--surface);
        border: 2px solid var(--accent);
        box-shadow: 0 4px 15px rgba(31, 42, 68, 0.2);
      }

      .scroll-range:disabled {
        cursor: not-allowed;
        opacity: 0.35;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .question {
        padding: 24px 24px 22px;
        border-radius: 22px;
        border: 1px solid rgba(108, 122, 224, 0.15);
        background: linear-gradient(135deg, rgba(108, 122, 224, 0.04), rgba(255, 255, 255, 0.9));
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .question-section {
        margin-bottom: 32px;
      }

      .question-section h3 {
        margin-bottom: 12px;
        font-size: 1.05rem;
        color: var(--accent-strong);
      }

      .question-head {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .question-required {
        font-size: 0.75rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--accent-strong);
      }

      .question-description {
        margin: -8px 0 8px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .survey-intro {
        padding: 20px 24px;
        border-radius: 22px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px dashed rgba(108, 122, 224, 0.35);
        margin-bottom: 12px;
      }

      .survey-intro h2 {
        margin: 0 0 8px;
        font-size: 1.2rem;
      }

      .survey-intro p {
        margin: 6px 0;
        color: var(--muted);
        line-height: 1.6;
      }

      .question-title {
        font-size: 1.05rem;
        margin: 0 0 16px;
        font-weight: 600;
      }

      .options {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .option {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid transparent;
        cursor: pointer;
        transition: border 0.2s ease, transform 0.2s ease;
      }

      .option:hover {
        border-color: rgba(108, 122, 224, 0.4);
        transform: translateY(-1px);
      }

      .option input {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid var(--muted);
        display: grid;
        place-items: center;
        margin: 0;
      }

      .option input::after {
        content: "";
        width: 8px;
        height: 8px;
        background: var(--accent);
        border-radius: 50%;
        transform: scale(0);
        transition: transform 0.15s ease;
      }

      .option input:checked {
        border-color: var(--accent);
      }

      .option input:checked::after {
        transform: scale(1);
      }

      .option input[type="checkbox"] {
        border-radius: 6px;
      }

      .option input[type="checkbox"]::after {
        border-radius: 2px;
      }

      .badge {
        width: 32px;
        height: 32px;
        border-radius: 16px;
        background: rgba(108, 122, 224, 0.15);
        color: var(--accent-strong);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
      }

      .option-text {
        font-size: 0.95rem;
      }

      .option-extra {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 0.9rem;
        margin-top: 6px;
      }

      .submit {
        border: none;
        border-radius: 18px;
        padding: 16px;
        background: linear-gradient(120deg, #6c7ae0, #8da2fb);
        color: white;
        font-size: 1rem;
        letter-spacing: 0.04em;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 18px 35px rgba(108, 122, 224, 0.3);
      }

      .editor-panel {
        gap: 20px;
        display: none;
      }

      .admin-mode .editor-panel {
        display: flex;
      }

      .logo-uploader {
        border: 1px dashed var(--border);
        border-radius: 20px;
        padding: 20px 22px;
        background: rgba(247, 249, 255, 0.84);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .logo-head {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }

      .logo-copy h3 {
        margin: 0;
        font-size: 1rem;
      }

      .logo-helper {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .logo-actions {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }

      .upload-btn {
        border-radius: 14px;
        padding: 10px 18px;
        background: rgba(108, 122, 224, 0.12);
        color: var(--accent-strong);
        font-weight: 600;
        cursor: pointer;
        border: 1px solid transparent;
        transition: transform 0.2s ease, border 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .upload-btn:hover {
        transform: translateY(-1px);
        border-color: rgba(108, 122, 224, 0.5);
      }

      .copy-editor {
        border: 1px dashed var(--border);
        border-radius: 20px;
        padding: 20px 22px;
        background: rgba(247, 249, 255, 0.84);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .copy-head h3 {
        margin: 0;
        font-size: 1rem;
      }

      .copy-helper {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .copy-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px 16px;
      }

      .copy-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.9rem;
      }

      .copy-field textarea {
        min-height: 72px;
        resize: vertical;
      }

      .stats-panel {
        background: var(--surface);
        border-radius: 28px;
        padding: 32px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.06);
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .stats-helper {
        margin: 0;
        color: var(--muted);
      }

      .stats-list {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .stats-card {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 22px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .stats-card h3 {
        margin: 0;
        font-size: 1rem;
      }

      .stats-total {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .stats-option {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 10px 0;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
      }

      .stats-option:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      .stats-section {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .stats-section + .stats-section {
        margin-top: 28px;
      }

      .stats-section h3 {
        margin: 0;
        font-size: 1rem;
        color: var(--accent-strong);
      }

      .stats-text-note {
        margin: 4px 0 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .response-panel {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 22px;
        padding: 24px;
        background: rgba(247, 249, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .response-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .response-helper {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .response-feed {
        display: flex;
        flex-direction: column;
        gap: 14px;
        max-height: 360px;
        overflow-y: auto;
      }

      .response-entry {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 18px;
        padding: 14px 16px;
        background: white;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .response-entry time {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .response-answer {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.55;
      }

      .response-empty {
        margin: 0;
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .option-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.92rem;
      }

      .option-head strong {
        color: var(--accent-strong);
        letter-spacing: 0.08em;
      }

      .progress {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.08);
        overflow: hidden;
      }

      .progress span {
        display: block;
        height: 100%;
        background: linear-gradient(90deg, #6c7ae0, #8da2fb);
      }

      .stats-empty {
        margin: 0;
        padding: 24px;
        text-align: center;
        border-radius: 18px;
        border: 1px dashed var(--border);
        color: var(--muted);
        background: rgba(247, 249, 255, 0.8);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }

      .editor-divider {
        height: 1px;
        width: 100%;
        background: linear-gradient(
          90deg,
          rgba(108, 122, 224, 0),
          rgba(108, 122, 224, 0.35),
          rgba(108, 122, 224, 0)
        );
      }

      .editor-list {
        display: flex;
        flex-direction: column;
        gap: 18px;
        overflow-y: auto;
        padding-right: 4px;
        scroll-behavior: smooth;
        max-height: clamp(280px, 48vh, 520px);
        min-height: 240px;
        border-radius: 16px;
        padding-bottom: 4px;
      }

      .editor-card {
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 20px;
        background: rgba(247, 249, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .editor-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .editor-card header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .remove {
        border: none;
        background: rgba(255, 67, 86, 0.12);
        color: #d8344e;
        border-radius: 12px;
        padding: 6px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      label span {
        font-size: 0.85rem;
        color: var(--muted);
        display: inline-block;
        margin-bottom: 6px;
      }

      textarea,
      input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: white;
        font-size: 0.95rem;
        resize: vertical;
        min-height: 42px;
      }

      textarea {
        min-height: 64px;
      }

      textarea:focus,
      input[type="text"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--soft);
      }

      @media (max-width: 1024px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .editor-panel {
          max-height: none;
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 32px 16px 48px;
        }

        .hero {
          flex-direction: column;
        }

        .hero-brand {
          flex-direction: column;
          align-items: flex-start;
        }

        .hero-actions {
          width: 100%;
          align-items: flex-start;
        }

        .panel {
          padding: 24px;
        }

        .qr-card {
          grid-template-columns: 1fr;
          padding: 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header class="hero">
        <div class="hero-brand">
          <img src="./assets/logo.svg" alt="After Wags logo" class="hero-logo" />
          <div class="hero-copy">
            <p class="eyebrow" id="hero-eyebrow">Live Survey Builder</p>
            <h1 id="hero-title">Pet Toy Sustainability Survey</h1>
            <p id="hero-desc">
              Preview every tweak instantly, share QR links, and collaborate in two languages with a modern, minimal layout.
            </p>
          </div>
        </div>
        <div class="hero-actions">
          <button id="lang-toggle" class="toggle" type="button">切换到 English</button>
          <button id="admin-button" class="ghost" type="button">管理员入口</button>
          <button id="exit-admin-button" class="ghost" type="button" hidden>退出管理员模式</button>
        </div>
      </header>

      <section class="qr-card">
        <div class="qr-content">
          <p class="eyebrow" id="qr-label">Scan to open</p>
          <h2 id="qr-title">QR entry point</h2>
          <p class="qr-helper" id="qr-helper">
            Share the survey link to any channel and let people scan to open it instantly. Customize the URL to match your deployment.
          </p>
          <div class="qr-form">
            <label>
              <span id="qr-input-label">Destination URL</span>
              <input id="qr-url" type="url" placeholder="https://example.com/survey" />
            </label>
            <div class="qr-actions">
              <button id="qr-refresh" class="ghost" type="button">Update QR code</button>
            </div>
          </div>
        </div>
        <div class="qr-preview">
          <div id="qr-code" class="qr-canvas" aria-label="二维码"></div>
          <p class="qr-note" id="qr-note">Scan on mobile to open the survey</p>
        </div>
      </section>

      <nav class="page-tabs">
        <button id="tab-builder" class="tab-btn active" type="button">Survey builder</button>
        <button id="tab-stats" class="tab-btn" type="button">Response stats</button>
      </nav>

      <section id="builder-view" class="layout builder-view">
        <div class="panel preview-panel">
          <div class="panel-header">
            <div>
              <p class="eyebrow" id="preview-label">Preview</p>
              <h2 id="preview-title">What participants will see</h2>
            </div>
          </div>

          <form id="question-list" novalidate></form>
          <button id="submit-btn" class="submit" type="button">Submit survey</button>
        </div>

        <div class="panel editor-panel" hidden aria-hidden="true">
          <div class="panel-header">
            <div>
              <p class="eyebrow" id="editor-label">Editor</p>
              <h2 id="editor-title">Update questions & options</h2>
            </div>
            <div class="panel-actions">
              <button id="save-editor" class="toggle" type="button">Save changes</button>
            </div>
          </div>

          <div class="logo-uploader">
            <div class="logo-head">
              <div class="logo-copy">
                <p class="eyebrow" id="logo-label">Brand logo</p>
                <h3 id="logo-title">Upload your own mark</h3>
                <p class="logo-helper" id="logo-helper">
                  Supports PNG / JPG / SVG (≤2MB). Transparent backgrounds work best.
                </p>
              </div>
              <div class="logo-actions">
                <label class="upload-btn">
                  <input id="logo-input" type="file" accept="image/*" hidden />
                  <span id="logo-upload-text">Upload image</span>
                </label>
                <button id="logo-reset" class="ghost-small" type="button">Reset</button>
              </div>
            </div>
          </div>

          <div id="copy-editor" class="copy-editor"></div>

          <div class="editor-divider"></div>
          <div class="editor-controls">
            <div class="scroll-control">
              <span class="scroll-label" id="scroll-editor-label">Drag to scroll questions</span>
              <input
                id="scroll-editor-range"
                class="scroll-range"
                type="range"
                min="0"
                max="100"
                value="0"
              />
            </div>
            <button id="add-question" class="ghost" type="button">Add question</button>
          </div>
          <div id="editor-list" class="editor-list"></div>
        </div>
      </section>

      <section id="stats-view" class="stats-panel" hidden>
        <div class="panel-header">
          <div>
            <p class="eyebrow" id="stats-label">Response stats</p>
            <h2 id="stats-title">Overall answer overview</h2>
          </div>
        </div>
        <p class="stats-helper" id="stats-helper">Track the preference for each option and monitor trends in real time.</p>
        <div id="stats-content" class="stats-list"></div>
        <p id="stats-empty" class="stats-empty" hidden>No submissions yet.</p>
        <div class="response-panel">
          <div class="response-head">
            <div>
              <p class="eyebrow" id="responses-label">Response log</p>
              <h3 id="responses-title">Latest submissions</h3>
            </div>
            <button id="response-refresh" class="ghost-small" type="button">Refresh list</button>
          </div>
          <p class="response-helper" id="responses-helper">
            Pulls the 50 most recent responses from Supabase so you can review open text answers and choices.
          </p>
          <div id="response-feed" class="response-feed"></div>
          <p id="response-empty" class="response-empty">No submissions have been synced yet.</p>
        </div>
      </section>

    </div>

    <script>
      const surveyIntro = {
        zh: {
          title: "Play More, Buy Less: A Survey for Dog and Cat Owners",
          description: [
            "Thank you for taking the time to visit this survey. We are a student research team from the MFA Design for Social Innovation program at the School of Visual Arts (SVA) in New York.",
            "This anonymous survey (about 5 minutes) is for dog and cat owners who buy toys for their pets. We would like to learn how you purchase, use, and handle pet toys, your views on eco-friendly materials, and your interest in DIY pet toys. Your answers will help us understand what makes DIY difficult in real life, and how we might turn “buy then idle” toys into “make, reuse, and play longer.”",
            "Participation is completely voluntary. You may skip any question you do not wish to answer. All responses will be used only for academic research and design purposes and will not be shared in a way that can identify you."
          ]
        },
        en: {
          title: "Play More, Buy Less: A Survey for Dog and Cat Owners",
          description: [
            "Thank you for taking the time to visit this survey. We are a student research team from the MFA Design for Social Innovation program at the School of Visual Arts (SVA) in New York.",
            "This anonymous survey (about 5 minutes) is for dog and cat owners who buy toys for their pets. We would like to learn how you purchase, use, and handle pet toys, your views on eco-friendly materials, and your interest in DIY pet toys. Your answers will help us understand what makes DIY difficult in real life, and how we might turn “buy then idle” toys into “make, reuse, and play longer.”",
            "Participation is completely voluntary. You may skip any question you do not wish to answer. All responses will be used only for academic research and design purposes and will not be shared in a way that can identify you."
          ]
        }
      };

      const questionSections = [
        {
          id: "purchase",
          zh: { title: "Section 1. Pet Toy Purchasing Behavior & Motivation", summary: "Frequency, spend, and purchase drivers." },
          en: { title: "Section 1. Pet Toy Purchasing Behavior & Motivation", summary: "Frequency, spend, and purchase drivers." }
        },
        {
          id: "usage",
          zh: { title: "Section 2. Toy Usage & Disposal Patterns", summary: "Usage, damage, idle handling, and DIY interest." },
          en: { title: "Section 2. Toy Usage & Disposal Patterns", summary: "Usage, damage, idle handling, and DIY interest." }
        },
        {
          id: "sustainability",
          zh: { title: "Section 3. Awareness & Attitudes Toward Sustainable Pet Products", summary: "Awareness, importance, and price sensitivity." },
          en: { title: "Section 3. Awareness & Attitudes Toward Sustainable Pet Products", summary: "Awareness, importance, and price sensitivity." }
        },
        {
          id: "reuse",
          zh: { title: "Section 4. Attitudes Toward Toy Reuse / Recycling / Donation", summary: "Participation, factors, and redesign interest." },
          en: { title: "Section 4. Attitudes Toward Toy Reuse / Recycling / Donation", summary: "Participation, factors, and redesign interest." }
        },
        {
          id: "basic",
          zh: { title: "Section 5. More information", summary: "Pet types, age range, and occupation." },
          en: { title: "Section 5. More information", summary: "Pet types, age range, and occupation." }
        },
        {
          id: "open",
          zh: { title: "Section 6. Open-Ended Questions", summary: "Short answers and optional interview email." },
          en: { title: "Section 6. Open-Ended Questions", summary: "Short answers and optional interview email." }
        }
      ];

      const uiMeta = {
        zh: {
          toggle: "切换到 English",
          remove: "删除",
          questionTitle: (index) => `问题 ${index}`,
          questionPlaceholder: "请输入题目内容",
          notePlaceholder: "（可选）补充说明",
          optionPlaceholder: (index) => `选项 ${index}`,
          adminButton: "管理员入口",
          exitAdminButton: "退出管理员模式",
          adminPrompt: "请输入管理员密码",
          adminError: "密码错误，请重试",
          tabBuilder: "问卷设计",
          tabStats: "回答统计",
          statsLabel: "回答统计",
          statsTitle: "整体回答概览",
          statsHelper: "查看每个选项被选择的次数，追踪不同题目的回答趋势。",
          statsEmpty: "还没有任何提交记录。",
          submitSuccess: "提交成功，感谢反馈！",
          responsesLabel: (count) => `共 ${count} 份回答`,
          responsesPanelLabel: "回答记录",
          responsesPanelTitle: "最新提交",
          responsesHelper: "自动从 Supabase 获取最近 50 条回答，方便查看开放题文本与具体选择。",
          responsesEmpty: "暂时没有回答记录。",
          responsesRefresh: "刷新列表",
          responsesLoading: "正在加载最新的回答记录…",
          responsesError: "暂时无法获取回答，请稍后再试。",
          qrLabel: "扫码直达",
          qrTitle: "二维码入口",
          qrHelper: "将问卷链接分享到任何渠道，扫码即可直接打开当前页面。可自定义网址来匹配部署地址。",
          qrInputLabel: "跳转链接",
          qrRefresh: "更新二维码",
          qrNote: "手机扫码立即打开问卷",
          qrInvalid: "请输入有效的 http(s) 链接。",
          logoLabel: "品牌 Logo",
          logoTitle: "上传自定义图像",
          logoHelper: "支持 PNG / JPG / SVG（≤2MB），建议透明背景。",
          logoUpload: "上传图片",
          logoReset: "恢复默认",
          copyLabel: "页面文案",
          copyTitle: "编辑展示文字",
          copyHelper: "针对当前语言编辑抬头、按钮等所有显示给用户的文字内容。",
          copyFieldLabels: {
            heroEyebrow: "信息条",
            heroTitle: "主标题",
            heroDesc: "描述 / 引言",
            previewLabel: "预览区标签",
            previewTitle: "预览区副标题",
            editorLabel: "编辑区标签",
            editorTitle: "编辑区副标题",
            scrollDown: "“下滑条”提示文案",
            addQuestion: "“新增问题”按钮",
            submit: "提交按钮"
          },
          saveChanges: "保存编辑",
          saveSuccess: "已保存到云端，可在其他设备继续编辑。",
          requiredError: "请完成所有必答题。",
          textQuestionNote: (count) =>
            count ? `已收集 ${count} 条开放回答，请在后台查看详情。` : "等待第一条开放回答。"
        },
        en: {
          toggle: "Switch to 中文",
          remove: "Remove",
          questionTitle: (index) => `Question ${index}`,
          questionPlaceholder: "Enter the prompt",
          notePlaceholder: "Optional helper text",
          optionPlaceholder: (index) => `Option ${index}`,
          adminButton: "Admin console",
          exitAdminButton: "Exit admin mode",
          adminPrompt: "Enter the admin password",
          adminError: "Incorrect password. Try again.",
          tabBuilder: "Survey builder",
          tabStats: "Response stats",
          statsLabel: "Response stats",
          statsTitle: "Overall response overview",
          statsHelper: "Track how often each option is chosen to understand response trends.",
          statsEmpty: "No submissions yet.",
          submitSuccess: "Thanks! Your feedback has been recorded.",
          responsesLabel: (count) => `${count} submissions`,
          responsesPanelLabel: "Response log",
          responsesPanelTitle: "Latest submissions",
          responsesHelper: "Pulls the 50 most recent entries from Supabase so you can review open-text answers.",
          responsesEmpty: "No submissions have been synced yet.",
          responsesRefresh: "Refresh list",
          responsesLoading: "Loading the latest submissions…",
          responsesError: "Unable to load responses. Please try again later.",
          qrLabel: "Scan to open",
          qrTitle: "QR entry point",
          qrHelper: "Share this survey anywhere—scanning the code opens the link instantly.",
          qrInputLabel: "Destination URL",
          qrRefresh: "Update QR code",
          qrNote: "Scan on mobile to open the survey",
          qrInvalid: "Please enter a valid http(s) link.",
          logoLabel: "Brand Logo",
          logoTitle: "Upload your mark",
          logoHelper: "PNG / JPG / SVG up to 2 MB. Transparent background recommended.",
          logoUpload: "Upload image",
          logoReset: "Reset to default",
          copyLabel: "Page Copy",
          copyTitle: "Edit visible text",
          copyHelper: "Adjust every piece of wording the respondent sees for the current language.",
          copyFieldLabels: {
            heroEyebrow: "Eyebrow / Tagline",
            heroTitle: "Main title",
            heroDesc: "Description",
            previewLabel: "Preview label",
            previewTitle: "Preview subtitle",
            editorLabel: "Editor label",
            editorTitle: "Editor subtitle",
            scrollDown: "\"Scroll handle\" label",
            addQuestion: "\"Add question\" button",
            submit: "Submit button"
          },
          saveChanges: "Save changes",
          saveSuccess: "Saved remotely so you can continue anywhere.",
          requiredError: "Please answer every required question.",
          textQuestionNote: (count) =>
            count
              ? `${count} open responses collected. Check the admin data for details.`
              : "Waiting for the first open response."
        }
      };

      const copyFieldConfig = [
        { id: "heroEyebrow", type: "text" },
        { id: "heroTitle", type: "text" },
        { id: "heroDesc", type: "textarea" },
        { id: "previewLabel", type: "text" },
        { id: "previewTitle", type: "text" },
        { id: "editorLabel", type: "text" },
        { id: "editorTitle", type: "text" },
        { id: "scrollDown", type: "text" },
        { id: "addQuestion", type: "text" },
        { id: "submit", type: "text" }
      ];

      const createId = () =>
        window.crypto?.randomUUID
          ? window.crypto.randomUUID()
          : `q-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;

      
      const defaultQuestions = [
        {
          id: "purchase-frequency",
          sectionId: "purchase",
          type: "single",
          required: true,
          text: { zh: "How often do you usually buy toys for your pet?", en: "How often do you usually buy toys for your pet?" },
          options: [
            { value: "weekly", label: { zh: "More than once a week", en: "More than once a week" } },
            { value: "biweekly", label: { zh: "Once every two weeks", en: "Once every two weeks" } },
            { value: "monthly-1-2", label: { zh: "1–2 times per month", en: "1–2 times per month" } },
            { value: "two-three-months", label: { zh: "Once every 2–3 months", en: "Once every 2–3 months" } },
            { value: "six-month", label: { zh: "Once every 6 months", en: "Once every 6 months" } },
            { value: "yearly", label: { zh: "Once a year or less", en: "Once a year or less" } },
            { value: "mood", label: { zh: "Irregular / depends on mood", en: "Irregular / depends on mood" } }
          ]
        },
        {
          id: "purchase-monthly-spend",
          sectionId: "purchase",
          type: "single",
          required: true,
          text: { zh: "Approximately how much do you spend on pet toys per month (USD)?", en: "Approximately how much do you spend on pet toys per month (USD)?" },
          options: [
            { value: "lt20", label: { zh: "Less than $20", en: "Less than $20" } },
            { value: "20-50", label: { zh: "$20–50", en: "$20–50" } },
            { value: "50-100", label: { zh: "$50–100", en: "$50–100" } },
            { value: "100-200", label: { zh: "$100–200", en: "$100–200" } },
            { value: "gt200", label: { zh: "More than $200", en: "More than $200" } }
          ]
        },
        {
          id: "purchase-motivation",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "What are your main motivations for purchasing pet toys? (Select all that apply)", en: "What are your main motivations for purchasing pet toys? (Select all that apply)" },
          options: [
            { value: "replace", label: { zh: "My pet breaks old toys and needs replacements", en: "My pet breaks old toys and needs replacements" } },
            { value: "social", label: { zh: "Influenced by social media or influencers", en: "Influenced by social media or influencers" } },
            { value: "holiday", label: { zh: "Holiday or special-occasion gifts", en: "Holiday or special-occasion gifts" } },
            { value: "cute", label: { zh: "I find the toys cute / aesthetically pleasing", en: "I find the toys cute / aesthetically pleasing" } },
            { value: "new", label: { zh: "I want my pet to try something new", en: "I want my pet to try something new" } },
            { value: "motivation-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "purchase-channel",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "Where do you usually purchase pet toys? (Select all that apply)", en: "Where do you usually purchase pet toys? (Select all that apply)" },
          options: [
            { value: "ecommerce", label: { zh: "E-commerce platforms (Amazon,Taobao etc.)", en: "E-commerce platforms (Amazon,Taobao etc.)" } },
            { value: "local", label: { zh: "Local pet stores", en: "Local pet stores" } },
            { value: "social", label: { zh: "Social media platforms (TikTok, Instagram, RedNote etc.)", en: "Social media platforms (TikTok, Instagram, RedNote etc.)" } },
            { value: "brand", label: { zh: "Brand websites", en: "Brand websites" } },
            { value: "channel-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "purchase-factors",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "What factors affect your willingness to purchase pet toys? (Select all that apply)", en: "What factors affect your willingness to purchase pet toys? (Select all that apply)" },
          options: [
            { value: "price", label: { zh: "Price is too high", en: "Price is too high" } },
            { value: "aesthetic", label: { zh: "The product does not match my personal aesthetic", en: "The product does not match my personal aesthetic" } },
            { value: "lose-interest", label: { zh: "I think my pet will quickly lose interest", en: "I think my pet will quickly lose interest" } },
            { value: "quality", label: { zh: "Poor quality / breaks easily", en: "Poor quality / breaks easily" } },
            { value: "safety", label: { zh: "Concerns about material safety or odor", en: "Concerns about material safety or odor" } },
            { value: "already", label: { zh: "Already purchased too many / similar toys at home", en: "Already purchased too many / similar toys at home" } },
            { value: "storage", label: { zh: "Lack of storage space", en: "Lack of storage space" } },
            { value: "trust", label: { zh: "Distrust of the brand or its advertising", en: "Distrust of the brand or its advertising" } },
            { value: "factor-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "purchase-restraint",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "In what situations do you usually control or restrain your desire to buy toys? (Select all that apply)", en: "In what situations do you usually control or restrain your desire to buy toys? (Select all that apply)" },
          options: [
            { value: "spent-too-much", label: { zh: "Feeling like I’ve spent too much recently", en: "Feeling like I’ve spent too much recently" } },
            { value: "pet-doesnt-need", label: { zh: "My pet does not truly need a new toy", en: "My pet does not truly need a new toy" } },
            { value: "friends-remind", label: { zh: "Reminded by friends/family to spend rationally", en: "Reminded by friends/family to spend rationally" } },
            { value: "reviews", label: { zh: "Product reviews or inspections make it seem not worth it", en: "Product reviews or inspections make it seem not worth it" } },
            { value: "environment", label: { zh: "Environmental or sustainability concerns", en: "Environmental or sustainability concerns" } },
            { value: "restraint-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "usage-interest-time",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "On average, how long does it take for your pet to lose interest in a toy?", en: "On average, how long does it take for your pet to lose interest in a toy?" },
          options: [
            { value: "hours", label: { zh: "Within a few hours", en: "Within a few hours" } },
            { value: "days", label: { zh: "Within 1–3 days", en: "Within 1–3 days" } },
            { value: "week", label: { zh: "About 1 week", en: "About 1 week" } },
            { value: "month", label: { zh: "About 1 month", en: "About 1 month" } },
            { value: "3months", label: { zh: "Still interested after 3 months", en: "Still interested after 3 months" } },
            { value: "depends", label: { zh: "Depends on the type of toy", en: "Depends on the type of toy" } },
            { value: "unsure", label: { zh: "Not sure / haven’t noticed", en: "Not sure / haven’t noticed" } }
          ]
        },
        {
          id: "usage-damage-time",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "On average, how long does it take for your pet’s toys to become damaged?", en: "On average, how long does it take for your pet’s toys to become damaged?" },
          options: [
            { value: "hours", label: { zh: "Within a few hours", en: "Within a few hours" } },
            { value: "days", label: { zh: "Within 1–3 days", en: "Within 1–3 days" } },
            { value: "week", label: { zh: "About 1 week", en: "About 1 week" } },
            { value: "month", label: { zh: "About 1 month", en: "About 1 month" } },
            { value: "3months", label: { zh: "Still usable after 3 months", en: "Still usable after 3 months" } },
            { value: "depends", label: { zh: "Depends on the type of toy", en: "Depends on the type of toy" } },
            { value: "unsure", label: { zh: "Not sure / haven’t noticed", en: "Not sure / haven’t noticed" } }
          ]
        },
        {
          id: "usage-toy-count",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "How many toys does your pet currently have?", en: "How many toys does your pet currently have?" },
          options: [
            { value: "1-3", label: { zh: "1–3", en: "1–3" } },
            { value: "4-6", label: { zh: "4–6", en: "4–6" } },
            { value: "7-10", label: { zh: "7–10", en: "7–10" } },
            { value: "10+", label: { zh: "More than 10", en: "More than 10" } }
          ]
        },
        {
          id: "usage-favorite-share",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "What percentage of the toys does your pet frequently play with?", en: "What percentage of the toys does your pet frequently play with?" },
          options: [
            { value: "80plus", label: { zh: "Over 80%", en: "Over 80%" } },
            { value: "half", label: { zh: "About half", en: "About half" } },
            { value: "less-half", label: { zh: "Less than half", en: "Less than half" } },
            { value: "few-favorites", label: { zh: "Only one or two favorites", en: "Only one or two favorites" } }
          ]
        },
        {
          id: "usage-unused",
          sectionId: "usage",
          type: "multi",
          required: true,
          text: { zh: "How do you usually handle unused toys? (Select all that apply)", en: "How do you usually handle unused toys? (Select all that apply)" },
          options: [
            { value: "discard", label: { zh: "Throw them away", en: "Throw them away" } },
            { value: "store", label: { zh: "Store them without using", en: "Store them without using" } },
            { value: "repurpose", label: { zh: "Repurpose into other toys", en: "Repurpose into other toys" } },
            { value: "clean", label: { zh: "Clean and reuse", en: "Clean and reuse" } },
            { value: "donate", label: { zh: "Give away / donate", en: "Give away / donate" } },
            { value: "unused-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "usage-damaged",
          sectionId: "usage",
          type: "multi",
          required: true,
          text: { zh: "How do you usually handle damaged toys? (Select all that apply)", en: "How do you usually handle damaged toys? (Select all that apply)" },
          options: [
            { value: "discard", label: { zh: "Throw them away", en: "Throw them away" } },
            { value: "store", label: { zh: "Store them without using", en: "Store them without using" } },
            { value: "repurpose", label: { zh: "Repurpose into other toys", en: "Repurpose into other toys" } },
            { value: "clean", label: { zh: "Clean and reuse", en: "Clean and reuse" } },
            { value: "donate", label: { zh: "Give away / donate", en: "Give away / donate" } },
            { value: "damaged-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "diy-willingness",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "Are you willing to make DIY toys for your pet?", en: "Are you willing to make DIY toys for your pet?" },
          options: [
            { value: "very", label: { zh: "Very willing — I enjoy crafting", en: "Very willing — I enjoy crafting" } },
            { value: "with-guide", label: { zh: "Willing, but only with tutorials/guidance", en: "Willing, but only with tutorials/guidance" } },
            { value: "concerned", label: { zh: "I’m interested, but concerned about safety or pet disliking it", en: "I’m interested, but concerned about safety or pet disliking it" } },
            { value: "not-enjoy", label: { zh: "I’m interested, but don’t enjoy crafting", en: "I’m interested, but don’t enjoy crafting" } }
          ]
        },
        {
          id: "diy-comment",
          sectionId: "usage",
          type: "text",
          required: false,
          text: { zh: "Additional comment", en: "Additional comment" },
          placeholder: { zh: "Optional", en: "Optional" }
        },
        {
          id: "sustain-awareness",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "Have you heard of “sustainable pet products” or “eco-friendly pet toys”?", en: "Have you heard of “sustainable pet products” or “eco-friendly pet toys”?" },
          options: [
            { value: "aware", label: { zh: "Yes, and I understand the concept", en: "Yes, and I understand the concept" } },
            { value: "heard", label: { zh: "Yes, but I do not understand much about it", en: "Yes, but I do not understand much about it" } },
            { value: "learn", label: { zh: "No,but want to learn more", en: "No,but want to learn more" } },
            { value: "not-interested", label: { zh: "No, not interested in it at all", en: "No, not interested in it at all" } }
          ]
        },
        {
          id: "sustain-importance",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "How important do you think eco-friendly or recyclable materials are when choosing pet toys?", en: "How important do you think eco-friendly or recyclable materials are when choosing pet toys?" },
          options: [
            { value: "very", label: { zh: "Very important", en: "Very important" } },
            { value: "somewhat", label: { zh: "Somewhat important", en: "Somewhat important" } },
            { value: "neutral", label: { zh: "Neutral", en: "Neutral" } },
            { value: "not-very", label: { zh: "Not very important", en: "Not very important" } },
            { value: "not-at-all", label: { zh: "Not important at all", en: "Not important at all" } }
          ]
        },
        {
          id: "sustain-premium",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "If eco-friendly pet toys cost slightly higher than regular ones, would you be willing to purchase them?", en: "If eco-friendly pet toys cost slightly higher than regular ones, would you be willing to purchase them?" },
          options: [
            { value: "yes", label: { zh: "Yes", en: "Yes" } },
            { value: "depends", label: { zh: "Depends on the situation", en: "Depends on the situation" } },
            { value: "no", label: { zh: "No", en: "No" } }
          ]
        },
        {
          id: "reuse-participation",
          sectionId: "reuse",
          type: "single",
          required: true,
          text: { zh: "If a brand or platform offered toy recycling,/refurbishing,/ or donation services, would you participate?", en: "If a brand or platform offered toy recycling,/refurbishing,/ or donation services, would you participate?" },
          options: [
            { value: "definitely", label: { zh: "Definitely", en: "Definitely" } },
            { value: "probably", label: { zh: "Probably", en: "Probably" } },
            { value: "depends", label: { zh: "Depends", en: "Depends" } },
            { value: "no", label: { zh: "No", en: "No" } }
          ]
        },
        {
          id: "reuse-factors",
          sectionId: "reuse",
          type: "multi",
          required: true,
          text: { zh: "What factors influence your willingness to participate in toy reuse programs? (Select all that apply)", en: "What factors influence your willingness to participate in toy reuse programs? (Select all that apply)" },
          options: [
            { value: "convenience", label: { zh: "Convenience (easily accessible drop-off points)", en: "Convenience (easily accessible drop-off points)" } },
            { value: "hygiene", label: { zh: "Hygiene and safety concerns", en: "Hygiene and safety concerns" } },
            { value: "quantity", label: { zh: "Number of unused toys at home", en: "Number of unused toys at home" } },
            { value: "fees", label: { zh: "Service fees", en: "Service fees" } },
            { value: "trust", label: { zh: "Trust in the organization", en: "Trust in the organization" } },
            { value: "rewards", label: { zh: "Rewards or incentives", en: "Rewards or incentives" } },
            { value: "responsibility", label: { zh: "Environmental or social responsibility awareness", en: "Environmental or social responsibility awareness" } },
            { value: "reuse-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "reuse-redesign",
          sectionId: "reuse",
          type: "single",
          required: true,
          text: { zh: "If old toys were redesigned into new products (e.g., pet accessories or decorative items), would you consider using or purchasing them?", en: "If old toys were redesigned into new products (e.g., pet accessories or decorative items), would you consider using or purchasing them?" },
          options: [
            { value: "very", label: { zh: "Very willing", en: "Very willing" } },
            { value: "interested", label: { zh: "Somewhat interested", en: "Somewhat interested" } },
            { value: "not-willing", label: { zh: "Not very willing", en: "Not very willing" } },
            { value: "not-interested", label: { zh: "Not interested at all", en: "Not interested at all" } }
          ]
        },
        {
          id: "basic-pet-type",
          sectionId: "basic",
          type: "multi",
          required: true,
          text: { zh: "What type(s) of pets do you have, and how many?", en: "What type(s) of pets do you have, and how many?" },
          options: [
            { value: "dog", label: { zh: "Dog(s):", en: "Dog(s):" }, hasTextInput: true, placeholder: { zh: "Enter number", en: "Enter number" } },
            { value: "cat", label: { zh: "Cat(s):", en: "Cat(s):" }, hasTextInput: true, placeholder: { zh: "Enter number", en: "Enter number" } }
          ]
        },
        {
          id: "basic-age",
          sectionId: "basic",
          type: "single",
          required: true,
          text: { zh: "What is your age range?", en: "What is your age range?" },
          options: [
            { value: "18-23", label: { zh: "18–23", en: "18–23" } },
            { value: "23-30", label: { zh: "23–30", en: "23–30" } },
            { value: "30-36", label: { zh: "30–36", en: "30–36" } },
            { value: "36-44", label: { zh: "36–44", en: "36–44" } }
          ]
        },
        {
          id: "basic-occupation",
          sectionId: "basic",
          type: "multi",
          required: true,
          text: { zh: "What is your current occupation or status? (Select all that apply)", en: "What is your current occupation or status? (Select all that apply)" },
          options: [
            { value: "student", label: { zh: "Student", en: "Student" } },
            { value: "fulltime", label: { zh: "Full-time employee", en: "Full-time employee" } },
            { value: "freelancer", label: { zh: "Freelancer", en: "Freelancer" } },
            { value: "occupation-other", label: { zh: "Other (please specify)", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "Please specify", en: "Please specify" } }
          ]
        },
        {
          id: "open-waste",
          sectionId: "open",
          type: "text",
          required: true,
          text: { zh: "In your opinion, what aspects of current pet toys are the most wasteful or unsustainable?", en: "In your opinion, what aspects of current pet toys are the most wasteful or unsustainable?" },
          placeholder: { zh: "Short answer", en: "Short answer" }
        },
        {
          id: "open-innovation",
          sectionId: "open",
          type: "text",
          required: true,
          text: { zh: "What improvements or innovations would you like to see in future pet toys?", en: "What improvements or innovations would you like to see in future pet toys?" },
          placeholder: { zh: "Short answer", en: "Short answer" }
        },
        {
          id: "open-diy-barrier",
          sectionId: "open",
          type: "text",
          required: true,
          text: { zh: "What currently discourages you the most from DIY-ing pet toys?", en: "What currently discourages you the most from DIY-ing pet toys?" },
          placeholder: { zh: "Short answer", en: "Short answer" }
        },
        {
          id: "open-email",
          sectionId: "open",
          type: "text",
          required: false,
          text: { zh: "Would you be open to a short interview in the future? If yes, please share your email address. Thank you!", en: "Would you be open to a short interview in the future? If yes, please share your email address. Thank you!" },
          placeholder: { zh: "Your email (optional)", en: "Your email (optional)" }
        }
      ];


      const defaultContent = {
        zh: {
          heroEyebrow: "Live Survey Builder",
          heroTitle: "宠物玩具与可持续问卷",
          heroDesc:
            "支持长列表题目、中英文切换、二维码分享与云端保存，帮助团队随时联合作业、实时发布更新。",
          previewLabel: "问卷预览",
          previewTitle: "受访者看到的样子",
          editorLabel: "编辑区",
          editorTitle: "实时更新问题与选项",
          scrollDown: "拖动滑条查看更多问题",
          addQuestion: "新增问题",
          submit: "提交问卷"
        },
        en: {
          heroEyebrow: "Live Survey Builder",
          heroTitle: "Pet Toy Sustainability Survey",
          heroDesc:
            "Manage a bilingual questionnaire with live preview, QR sharing, and collaborative cloud saves for the whole team.",
          previewLabel: "Preview",
          previewTitle: "What participants will see",
          editorLabel: "Editor",
          editorTitle: "Update questions & options",
          scrollDown: "Drag to scroll questions",
          addQuestion: "Add question",
          submit: "Submit survey"
        }
      };

      const DEFAULT_LOGO_SRC = "./assets/logo.svg";
      const LOGO_STORAGE_KEY = "survey-builder-logo";
      const LOGO_MAX_BYTES = 2 * 1024 * 1024;
      const QR_URL_STORAGE_KEY = "survey-builder-qr-url";
      const DEFAULT_QR_URL = "https://hanyangzhang001-svg.github.io/HANYANG/";
      const ADMIN_PASSWORD = "123456";
      const ADMIN_MODE_KEY = "survey-builder-admin-mode";
      const STORAGE_QUESTIONS_KEY = "survey-builder-questions";
      const STORAGE_CONTENT_KEY = "survey-builder-content";
      const REMOTE_SYNC_ENABLED = true;
      const RESPONSE_FETCH_LIMIT = 50;
      const STATS_FETCH_LIMIT = 500;
      const SUPABASE_URL = "https://tgckygkqjdihvdazqwqe.supabase.co";
      const SUPABASE_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRnY2t5Z2txamRpaHZkYXpxd3FlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4OTc1MjksImV4cCI6MjA3ODQ3MzUyOX0.GKcnJIL3Ffyj9HljHJqeWObuFOFImnUbCY5rZ8V9BHw";
      const SUPABASE_CONFIG_ENDPOINT = `${SUPABASE_URL}/rest/v1/survey_configs`;
      const SUPABASE_RESPONSES_ENDPOINT = `${SUPABASE_URL}/rest/v1/survey_responses`;
      const SUPABASE_CONFIG_ID = "main";

      const persistQuestions = () => {
        try {
          localStorage.setItem(STORAGE_QUESTIONS_KEY, JSON.stringify(questions));
        } catch (error) {
          console.warn("Unable to store questions", error);
        }
      };

      const persistContent = () => {
        try {
          localStorage.setItem(STORAGE_CONTENT_KEY, JSON.stringify(contentText));
        } catch (error) {
          console.warn("Unable to store content text", error);
        }
      };

      const supabaseHeaders = {
        apikey: SUPABASE_KEY,
        Authorization: `Bearer ${SUPABASE_KEY}`,
        "Content-Type": "application/json"
      };

      const fetchRemoteConfig = async () => {
        if (!REMOTE_SYNC_ENABLED) {
          return null;
        }
        try {
          const response = await fetch(
            `${SUPABASE_CONFIG_ENDPOINT}?id=eq.${SUPABASE_CONFIG_ID}&select=config`,
            {
              headers: supabaseHeaders
            }
          );
          if (!response.ok) throw new Error("Failed to fetch remote config");
          const data = await response.json();
          return data[0]?.config || null;
        } catch (error) {
          console.warn("Unable to fetch remote config", error);
          return null;
        }
      };

      const saveRemoteConfig = async (payload) => {
        if (!REMOTE_SYNC_ENABLED) {
          return null;
        }
        try {
          const response = await fetch(SUPABASE_CONFIG_ENDPOINT, {
            method: "POST",
            headers: { ...supabaseHeaders, Prefer: "resolution=merge-duplicates" },
            body: JSON.stringify({
              id: SUPABASE_CONFIG_ID,
              config: payload,
              updated_at: new Date().toISOString()
            })
          });
          if (!response.ok) throw new Error("Failed to save remote config");
          const raw = await response.text();
          if (!raw) {
            return null;
          }
          return JSON.parse(raw);
        } catch (error) {
          console.error("Unable to save remote config", error);
          throw error;
        }
      };

      const saveResponseSubmission = async (answers) => {
        try {
          await fetch(SUPABASE_RESPONSES_ENDPOINT, {
            method: "POST",
            headers: supabaseHeaders,
            body: JSON.stringify({
              answers,
              submitted_at: new Date().toISOString()
            })
          });
        } catch (error) {
          console.warn("Unable to persist response", error);
        }
      };

      const loadStoredQrUrl = () => {
        try {
          return localStorage.getItem(QR_URL_STORAGE_KEY);
        } catch (error) {
          console.warn("Unable to load QR url", error);
          return null;
        }
      };

      const persistQrUrl = (url) => {
        try {
          localStorage.setItem(QR_URL_STORAGE_KEY, url);
        } catch (error) {
          console.warn("Unable to store QR url", error);
        }
      };

      let currentLanguage = "en";
      let currentScreen = "builder";
      const loadSavedQuestions = () => {
        try {
          const stored = localStorage.getItem(STORAGE_QUESTIONS_KEY);
          if (!stored) return null;
          const parsed = JSON.parse(stored);
          return Array.isArray(parsed) && parsed.length ? parsed : null;
        } catch (error) {
          console.warn("Unable to load saved questions", error);
          return null;
        }
      };

      const loadSavedContent = () => {
        try {
          const stored = localStorage.getItem(STORAGE_CONTENT_KEY);
          if (!stored) return null;
          const parsed = JSON.parse(stored);
          if (!parsed || typeof parsed !== "object") return null;
          return parsed;
        } catch (error) {
          console.warn("Unable to load saved content", error);
          return null;
        }
      };

      const findSectionById = (sectionId) => questionSections.find((section) => section.id === sectionId);

      const findOptionByValue = (question, value) =>
        question?.options?.find((option) => option.value === value);

      const isValidQuestionSet = (list) =>
        Array.isArray(list) &&
        list.every(
          (item) =>
            typeof item === "object" &&
            item !== null &&
            item.id &&
            item.sectionId &&
            item.type &&
            item.text
        );

      const findQuestionById = (id) => questions.find((question) => question.id === id);

      let questions = loadSavedQuestions();
      if (!isValidQuestionSet(questions)) {
        questions = JSON.parse(JSON.stringify(defaultQuestions));
      }
      let contentText = loadSavedContent() || JSON.parse(JSON.stringify(defaultContent));
      let currentLogoDataUrl = null;
      let currentQrUrl = "";
      let adminEnabled = false;
      let responseFeedItems = [];
      let responseFeedLoading = false;
      let responseFeedError = null;
      let statsLoading = false;
      let statsError = null;
      let cloudTotals = {};
      let cloudSubmissionCount = 0;
      let cloudLastUpdated = null;

      const ui = {
        logoImage: document.querySelector(".hero-logo"),
        heroEyebrow: document.getElementById("hero-eyebrow"),
        heroTitle: document.getElementById("hero-title"),
        heroDesc: document.getElementById("hero-desc"),
        previewLabel: document.getElementById("preview-label"),
        previewTitle: document.getElementById("preview-title"),
        editorLabel: document.getElementById("editor-label"),
        editorTitle: document.getElementById("editor-title"),
        logoLabel: document.getElementById("logo-label"),
        logoTitle: document.getElementById("logo-title"),
        logoHelper: document.getElementById("logo-helper"),
        logoUploadText: document.getElementById("logo-upload-text"),
        logoResetButton: document.getElementById("logo-reset"),
        logoInput: document.getElementById("logo-input"),
        scrollDownLabel: document.getElementById("scroll-editor-label"),
        scrollRange: document.getElementById("scroll-editor-range"),
        addQuestion: document.getElementById("add-question"),
        submit: document.getElementById("submit-btn"),
        langToggle: document.getElementById("lang-toggle"),
        builderTab: document.getElementById("tab-builder"),
        statsTab: document.getElementById("tab-stats"),
        builderView: document.getElementById("builder-view"),
        statsView: document.getElementById("stats-view"),
        statsLabel: document.getElementById("stats-label"),
        statsTitle: document.getElementById("stats-title"),
        statsHelper: document.getElementById("stats-helper"),
        statsContent: document.getElementById("stats-content"),
        statsEmpty: document.getElementById("stats-empty"),
        responsesLabel: document.getElementById("responses-label"),
        responsesTitle: document.getElementById("responses-title"),
        responsesHelper: document.getElementById("responses-helper"),
        responsesEmpty: document.getElementById("response-empty"),
        responsesFeed: document.getElementById("response-feed"),
        responseRefresh: document.getElementById("response-refresh"),
        editorPanel: document.querySelector(".editor-panel"),
        qrLabel: document.getElementById("qr-label"),
        qrTitle: document.getElementById("qr-title"),
        qrHelper: document.getElementById("qr-helper"),
        qrInputLabel: document.getElementById("qr-input-label"),
        qrRefresh: document.getElementById("qr-refresh"),
        qrNote: document.getElementById("qr-note"),
        qrUrlInput: document.getElementById("qr-url"),
        qrCode: document.getElementById("qr-code"),
        adminButton: document.getElementById("admin-button"),
        exitAdminButton: document.getElementById("exit-admin-button"),
        saveButton: document.getElementById("save-editor")
      };

      const questionList = document.getElementById("question-list");
      const editorList = document.getElementById("editor-list");
      const copyEditor = document.getElementById("copy-editor");

      const isValidUrl = (value) => {
        if (!value) return false;
        try {
          const parsed = new URL(value);
          return parsed.protocol === "http:" || parsed.protocol === "https:";
        } catch (error) {
          return false;
        }
      };

      const renderQrCode = (value) => {
        if (!ui.qrCode) return;
        const img = document.createElement("img");
        img.alt = "二维码";
        img.width = 180;
        img.height = 180;
        img.src = `https://quickchart.io/qr?size=220&text=${encodeURIComponent(value)}`;
        img.referrerPolicy = "no-referrer";
        ui.qrCode.innerHTML = "";
        ui.qrCode.appendChild(img);
        currentQrUrl = value;
      };

      const initQrSection = () => {
        if (!ui.qrUrlInput) return;
        const stored = loadStoredQrUrl();
        const initialUrl =
          stored && isValidUrl(stored) ? stored : DEFAULT_QR_URL || window.location.href;
        ui.qrUrlInput.value = initialUrl;
        persistQrUrl(initialUrl);
        renderQrCode(initialUrl);
      };

      const updateQrFromInput = () => {
        if (!ui.qrUrlInput) return;
        const url = ui.qrUrlInput.value.trim();
        const meta = uiMeta[currentLanguage];
        if (!isValidUrl(url)) {
          alert(meta.qrInvalid);
          ui.qrUrlInput.focus();
          return;
        }
        persistQrUrl(url);
        renderQrCode(url);
      };

      const enableAdminMode = () => {
        if (adminEnabled) return;
        adminEnabled = true;
        document.body.classList.add("admin-mode");
        if (ui.editorPanel) {
          ui.editorPanel.hidden = false;
          ui.editorPanel.setAttribute("aria-hidden", "false");
        }
        if (ui.exitAdminButton) {
          ui.exitAdminButton.hidden = false;
        }
        sessionStorage.setItem(ADMIN_MODE_KEY, "true");
        const url = new URL(window.location.href);
        url.searchParams.set("admin", "1");
        window.history.replaceState({}, "", url.toString());
      };

      const disableAdminMode = () => {
        adminEnabled = false;
        document.body.classList.remove("admin-mode");
        if (ui.editorPanel) {
          ui.editorPanel.hidden = true;
          ui.editorPanel.setAttribute("aria-hidden", "true");
        }
        if (ui.exitAdminButton) {
          ui.exitAdminButton.hidden = true;
        }
        sessionStorage.removeItem(ADMIN_MODE_KEY);
        const url = new URL(window.location.href);
        url.searchParams.delete("admin");
        window.history.replaceState({}, "", url.toString());
      };

      const setText = (el, value) => {
        if (el) {
          el.textContent = value;
        }
      };

      const applyLogoSrc = (src) => {
        if (ui.logoImage) {
          ui.logoImage.src = src || DEFAULT_LOGO_SRC;
        }
      };

      const formatTimestamp = (value) => {
        if (!value) return "";
        try {
          const date = new Date(value);
          return new Intl.DateTimeFormat(currentLanguage === "zh" ? "zh-CN" : "en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit"
          }).format(date);
        } catch (error) {
          return value;
        }
      };

      const describeAnswer = (question, answerPayload) => {
        if (!question) {
          return typeof answerPayload === "string" ? answerPayload : "";
        }
        if (answerPayload === null || answerPayload === undefined) {
          return "";
        }
        if (typeof answerPayload === "string") {
          const option = findOptionByValue(question, answerPayload);
          return option?.label?.[currentLanguage] || answerPayload;
        }
        if (Array.isArray(answerPayload)) {
          return answerPayload
            .map((value) => findOptionByValue(question, value)?.label?.[currentLanguage] || value)
            .join(" / ");
        }
        switch (answerPayload.type) {
          case "single": {
            const option = findOptionByValue(question, answerPayload.selection);
            let textValue = option?.label?.[currentLanguage] || answerPayload.selection || "";
            if (answerPayload.otherText) {
              textValue += currentLanguage === "zh" ? `（补充：${answerPayload.otherText}）` : ` (note: ${answerPayload.otherText})`;
            }
            return textValue;
          }
          case "multi": {
            const selections = Array.isArray(answerPayload.selections) ? answerPayload.selections : [];
            const pieces = selections.map((value) => {
              const option = findOptionByValue(question, value);
              let label = option?.label?.[currentLanguage] || value;
              const extra = answerPayload.otherText?.[value];
              if (extra) {
                label += currentLanguage === "zh" ? `（补充：${extra}）` : ` (note: ${extra})`;
              }
              return label;
            });
            return pieces.join(" / ");
          }
          case "text":
            return answerPayload.text || "";
          default:
            return JSON.stringify(answerPayload);
        }
      };

      const aggregateCloudTotals = (records) => {
        const totals = {};
        records.forEach((record) => {
          const answers = record.answers || {};
          Object.entries(answers).forEach(([questionId, payload]) => {
            const question = questions.find((item) => item.id === questionId);
            if (!question || !payload) return;
            if (question.type === "single") {
              totals[questionId] = totals[questionId] || {};
              const selection = payload.selection;
              if (!selection) return;
              totals[questionId][selection] = (totals[questionId][selection] || 0) + 1;
            } else if (question.type === "multi") {
              totals[questionId] = totals[questionId] || {};
              (payload.selections || []).forEach((selection) => {
                totals[questionId][selection] = (totals[questionId][selection] || 0) + 1;
              });
            }
          });
        });
        return totals;
      };

      const loadStoredLogo = () => {
        try {
          const stored = localStorage.getItem(LOGO_STORAGE_KEY);
          if (stored) {
            currentLogoDataUrl = stored;
            applyLogoSrc(stored);
            return;
          }
        } catch (error) {
          console.warn("Unable to read stored logo", error);
        }
        currentLogoDataUrl = null;
        applyLogoSrc(DEFAULT_LOGO_SRC);
      };

      const persistLogo = (dataUrl) => {
        try {
          if (dataUrl) {
            localStorage.setItem(LOGO_STORAGE_KEY, dataUrl);
          } else {
            localStorage.removeItem(LOGO_STORAGE_KEY);
          }
        } catch (error) {
          console.warn("Unable to persist logo", error);
        }
      };

      const syncScrollHandle = () => {
        if (!editorList || !ui.scrollRange) return;
        const maxScroll = editorList.scrollHeight - editorList.clientHeight;
        const disabled = maxScroll <= 2;
        ui.scrollRange.disabled = disabled;
        if (disabled) {
          ui.scrollRange.value = 0;
          return;
        }
        const progress = (editorList.scrollTop / maxScroll) * 100;
        ui.scrollRange.value = progress;
      };

      const createQuestionElement = (question) => {
        const block = document.createElement("article");
        block.className = "question";
        block.dataset.questionId = question.id;

        const head = document.createElement("div");
        head.className = "question-head";
        const title = document.createElement("h3");
        title.className = "question-title";
        title.textContent = question.text?.[currentLanguage] || "";
        head.appendChild(title);
        if (question.required) {
          const required = document.createElement("span");
          required.className = "question-required";
          required.textContent = currentLanguage === "zh" ? "必答" : "Required";
          head.appendChild(required);
        }
        block.appendChild(head);

        const descriptionText = question.description?.[currentLanguage];
        if (descriptionText) {
          const description = document.createElement("p");
          description.className = "question-description";
          description.textContent = descriptionText;
          block.appendChild(description);
        }

        if (question.type === "text") {
          const textarea = document.createElement("textarea");
          textarea.name = question.id;
          textarea.required = Boolean(question.required);
          textarea.placeholder = question.placeholder?.[currentLanguage] || "";
          textarea.rows = question.longAnswer ? 4 : 3;
          block.appendChild(textarea);
          return block;
        }

        const optionsWrap = document.createElement("div");
        optionsWrap.className = "options";
        (question.options || []).forEach((option, index) => {
          const label = document.createElement("label");
          label.className = "option";

          const input = document.createElement("input");
          input.type = question.type === "multi" ? "checkbox" : "radio";
          input.name = question.id;
          input.value = option.value;
          if (question.type === "single" && question.required) {
            input.required = true;
          }

          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = index + 1;

          const optionText = document.createElement("span");
          optionText.className = "option-text";
          optionText.textContent = option.label?.[currentLanguage] || "";

          label.appendChild(input);
          label.appendChild(badge);
          label.appendChild(optionText);

          if (option.hasTextInput) {
            const extraInput = document.createElement("input");
            extraInput.type = "text";
            extraInput.className = "option-extra";
            extraInput.name = `${question.id}__${option.value}__text`;
            extraInput.placeholder = option.placeholder?.[currentLanguage] || "";
            extraInput.disabled = true;
            label.appendChild(extraInput);
            const syncExtraInput = () => {
              const active = question.type === "multi" ? input.checked : input.checked;
              extraInput.disabled = !active;
              extraInput.required = active;
              if (!active) {
                extraInput.value = "";
              }
            };
            input.addEventListener("change", syncExtraInput);
          }

          optionsWrap.appendChild(label);
        });
        block.appendChild(optionsWrap);
        return block;
      };

      const renderPreview = () => {
        if (!questionList) return;
        questionList.innerHTML = "";

        const intro = surveyIntro[currentLanguage];
        if (intro) {
          const introBlock = document.createElement("section");
          introBlock.className = "survey-intro";
          const introTitle = document.createElement("h2");
          introTitle.textContent = intro.title;
          introBlock.appendChild(introTitle);
          intro.description?.forEach((paragraph) => {
            const p = document.createElement("p");
            p.textContent = paragraph;
            introBlock.appendChild(p);
          });
          questionList.appendChild(introBlock);
        }

        questionSections.forEach((section) => {
          const sectionQuestions = questions.filter((question) => question.sectionId === section.id);
          if (!sectionQuestions.length) return;
          const sectionBlock = document.createElement("div");
          sectionBlock.className = "question-section";
          const heading = document.createElement("h3");
          heading.textContent = section[currentLanguage].title;
          sectionBlock.appendChild(heading);
          const summary = section[currentLanguage].summary;
          if (summary) {
            const summaryNode = document.createElement("p");
            summaryNode.className = "question-description";
            summaryNode.textContent = summary;
            sectionBlock.appendChild(summaryNode);
          }
          sectionQuestions.forEach((question) => {
            sectionBlock.appendChild(createQuestionElement(question));
          });
          questionList.appendChild(sectionBlock);
        });
      };

      const renderEditor = () => {
        if (!editorList) return;
        const meta = uiMeta[currentLanguage];
        editorList.innerHTML = "";
        questions.forEach((question, index) => {
          question.text = question.text || { zh: "", en: "" };
          question.description = question.description || { zh: "", en: "" };
          const card = document.createElement("article");
          card.className = "editor-card";

          const head = document.createElement("header");
          const title = document.createElement("h3");
          const sectionTitle = findSectionById(question.sectionId)?.[currentLanguage]?.title || "";
          title.textContent = `${meta.questionTitle(index + 1)} · ${sectionTitle}`;

          const removeButton = document.createElement("button");
          removeButton.className = "remove";
          removeButton.type = "button";
          removeButton.textContent = meta.remove;
          removeButton.addEventListener("click", () => {
            questions = questions.filter((item) => item.id !== question.id);
            renderEditor();
            renderPreview();
            renderStats();
          });

          head.appendChild(title);
          head.appendChild(removeButton);
          card.appendChild(head);

          const questionLabel = document.createElement("label");
          const questionSpan = document.createElement("span");
          questionSpan.textContent = meta.questionPlaceholder;
          const questionInput = document.createElement("textarea");
          questionInput.value = question.text[currentLanguage] || "";
          questionInput.addEventListener("input", (event) => {
            question.text[currentLanguage] = event.target.value;
            renderPreview();
            renderStats();
          });
          questionLabel.appendChild(questionSpan);
          questionLabel.appendChild(questionInput);
          card.appendChild(questionLabel);

          const noteLabel = document.createElement("label");
          const noteSpan = document.createElement("span");
          noteSpan.textContent = meta.notePlaceholder;
          const noteInput = document.createElement("input");
          noteInput.type = "text";
          noteInput.value = question.description[currentLanguage] || "";
          noteInput.placeholder = meta.notePlaceholder;
          noteInput.addEventListener("input", (event) => {
            question.description[currentLanguage] = event.target.value;
            renderPreview();
          });
          noteLabel.appendChild(noteSpan);
          noteLabel.appendChild(noteInput);
          card.appendChild(noteLabel);

          if (Array.isArray(question.options)) {
            question.options.forEach((option, optionIndex) => {
              option.label = option.label || { zh: "", en: "" };
              const optionLabel = document.createElement("label");
              const labelSpan = document.createElement("span");
              labelSpan.textContent = meta.optionPlaceholder(optionIndex + 1);
              const optionInput = document.createElement("input");
              optionInput.type = "text";
              optionInput.value = option.label[currentLanguage] || "";
              optionInput.addEventListener("input", (event) => {
                option.label[currentLanguage] = event.target.value;
                renderPreview();
                renderStats();
              });
              optionLabel.appendChild(labelSpan);
              optionLabel.appendChild(optionInput);
              card.appendChild(optionLabel);
            });
          }

          editorList.appendChild(card);
        });

        syncScrollHandle();
      };

      const renderStats = () => {
        if (!ui.statsContent) return;
        const meta = uiMeta[currentLanguage];
        if (statsLoading) {
          const loadingText = currentLanguage === "zh" ? "云端统计加载中…" : "Syncing latest data…";
          ui.statsContent.innerHTML = `<p class="loader">${loadingText}</p>`;
          if (ui.statsHelper) {
            ui.statsHelper.textContent = meta.statsHelper;
          }
          ui.statsEmpty.hidden = true;
          return;
        }
        if (statsError) {
          ui.statsContent.innerHTML = `<p class="error">${statsError.message || "Unable to load cloud stats"}</p>`;
          if (ui.statsHelper) {
            ui.statsHelper.textContent = meta.statsHelper;
          }
          return;
        }
        if (ui.statsHelper) {
          ui.statsHelper.textContent = cloudLastUpdated
            ? `${meta.statsHelper} · Last synced ${formatTimestamp(cloudLastUpdated)}`
            : meta.statsHelper;
        }
        if (!cloudSubmissionCount) {
          ui.statsContent.innerHTML = "";
          if (ui.statsEmpty) {
            ui.statsEmpty.hidden = false;
            ui.statsEmpty.textContent = meta.statsEmpty;
          }
          return;
        }
        if (ui.statsEmpty) {
          ui.statsEmpty.hidden = true;
        }
        ui.statsContent.innerHTML = "";
        questionSections.forEach((section) => {
          const sectionQuestions = questions.filter((question) => question.sectionId === section.id);
          if (!sectionQuestions.length) return;
          const sectionBlock = document.createElement("div");
          sectionBlock.className = "stats-section";
          const heading = document.createElement("h3");
          heading.textContent = section[currentLanguage].title;
          sectionBlock.appendChild(heading);

          sectionQuestions.forEach((question) => {
            const counts = cloudTotals[question.id] || {};
            const total = Object.values(counts).reduce((sum, value) => sum + value, 0);

            const card = document.createElement("article");
            card.className = "stats-card";

            const title = document.createElement("h3");
            title.textContent = question.text?.[currentLanguage] || "";
            card.appendChild(title);

            const totalText = document.createElement("p");
            totalText.className = "stats-total";
            totalText.textContent = meta.responsesLabel(total);
            card.appendChild(totalText);

            if (!question.options || !question.options.length || question.type === "text") {
              const note = document.createElement("p");
              note.className = "stats-text-note";
              note.textContent = meta.textQuestionNote(total);
              card.appendChild(note);
            } else {
              question.options.forEach((option) => {
                const optionWrap = document.createElement("div");
                optionWrap.className = "stats-option";

                const head = document.createElement("div");
                head.className = "option-head";

                const label = document.createElement("strong");
                label.textContent = option.label?.[currentLanguage] || "";

                const detail = document.createElement("span");
                const count = counts[option.value] || 0;
                const percent = total ? Math.round((count / total) * 100) : 0;
                detail.textContent = `${count} · ${percent}%`;

                head.appendChild(label);
                head.appendChild(detail);

                const progress = document.createElement("div");
                progress.className = "progress";
                const bar = document.createElement("span");
                bar.style.width = `${percent}%`;
                progress.appendChild(bar);

                optionWrap.appendChild(head);
                optionWrap.appendChild(progress);
                card.appendChild(optionWrap);
              });
            }

            sectionBlock.appendChild(card);
          });

          ui.statsContent.appendChild(sectionBlock);
        });
      };

      const renderResponseFeedList = () => {
        if (!ui.responsesFeed || !ui.responsesEmpty) return;
        const meta = uiMeta[currentLanguage];
        ui.responsesFeed.innerHTML = "";
        if (responseFeedLoading) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesLoading;
          return;
        }
        if (responseFeedError) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesError;
          return;
        }
        if (!responseFeedItems.length) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesEmpty;
          return;
        }
        ui.responsesEmpty.hidden = true;
        responseFeedItems.forEach((record) => {
          const entry = document.createElement("article");
          entry.className = "response-entry";

          const time = document.createElement("time");
          time.dateTime = record.submitted_at;
          time.textContent = formatTimestamp(record.submitted_at);
          entry.appendChild(time);

          const answers = record.answers && typeof record.answers === "object" ? record.answers : {};
          Object.entries(answers).forEach(([questionId, value]) => {
            const question = findQuestionById(questionId);
            if (!question) return;
            const description = describeAnswer(question, value);
            if (!description) return;

            const answerLine = document.createElement("p");
            answerLine.className = "response-answer";

            const strong = document.createElement("strong");
            strong.textContent = question.text?.[currentLanguage] || question.text?.zh || questionId;
            answerLine.appendChild(strong);
            answerLine.appendChild(document.createElement("br"));
            answerLine.appendChild(document.createTextNode(description));

            entry.appendChild(answerLine);
          });

          ui.responsesFeed.appendChild(entry);
        });
      };

      const fetchResponseFeed = async () => {
        const params = new URLSearchParams({
          select: "answers,submitted_at",
          order: "submitted_at.desc",
          limit: RESPONSE_FETCH_LIMIT
        });
        const requestUrl = `${SUPABASE_RESPONSES_ENDPOINT}?${params.toString()}`;
        const response = await fetch(requestUrl, { headers: supabaseHeaders });
        if (!response.ok) {
          throw new Error(`Failed to load response feed: ${response.status}`);
        }
        return response.json();
      };

      const loadResponseFeed = async () => {
        if (responseFeedLoading) return;
        responseFeedLoading = true;
        responseFeedError = null;
        renderResponseFeedList();
        try {
          const records = await fetchResponseFeed();
          responseFeedItems = Array.isArray(records)
            ? records.map((item) => ({
                submitted_at: item.submitted_at,
                answers: item.answers
              }))
            : [];
        } catch (error) {
          responseFeedError = error;
        } finally {
          responseFeedLoading = false;
          renderResponseFeedList();
        }
      };

      const switchScreen = (target) => {
        if (!ui.builderView || !ui.statsView) return;
        if (target === currentScreen) {
          if (target === "stats") {
            renderStats();
            loadCloudStats();
            loadResponseFeed();
          }
          return;
        }
        currentScreen = target;
        const showBuilder = target === "builder";
        ui.builderView.hidden = !showBuilder;
        ui.statsView.hidden = showBuilder;
        if (ui.builderTab) {
          ui.builderTab.classList.toggle("active", showBuilder);
        }
        if (ui.statsTab) {
          ui.statsTab.classList.toggle("active", !showBuilder);
        }
        if (!showBuilder) {
          renderStats();
          loadCloudStats();
          loadResponseFeed();
        }
      };

      const renderCopyEditor = () => {
        const meta = uiMeta[currentLanguage];
        const copy = contentText[currentLanguage];
        copyEditor.innerHTML = "";

        const head = document.createElement("div");
        head.className = "copy-head";
        const eyebrow = document.createElement("p");
        eyebrow.className = "eyebrow";
        eyebrow.textContent = meta.copyLabel;
        const heading = document.createElement("h3");
        heading.textContent = meta.copyTitle;
        head.appendChild(eyebrow);
        head.appendChild(heading);
        copyEditor.appendChild(head);

        const helper = document.createElement("p");
        helper.className = "copy-helper";
        helper.textContent = meta.copyHelper;
        copyEditor.appendChild(helper);

        const grid = document.createElement("div");
        grid.className = "copy-grid";

        copyFieldConfig.forEach((field) => {
          const wrapper = document.createElement("label");
          wrapper.className = "copy-field";

          const span = document.createElement("span");
          span.textContent = meta.copyFieldLabels[field.id];

          const control =
            field.type === "textarea" ? document.createElement("textarea") : document.createElement("input");
          if (field.type !== "textarea") {
            control.type = "text";
          }
          control.value = copy[field.id] || "";
          control.addEventListener("input", (event) => {
            contentText[currentLanguage][field.id] = event.target.value;
            updateUIText();
          });

          wrapper.appendChild(span);
          wrapper.appendChild(control);
          grid.appendChild(wrapper);
        });

        copyEditor.appendChild(grid);
      };

      const handleSubmit = async () => {
        if (!questionList) return;
        if (!questionList.reportValidity()) {
          return;
        }

        const meta = uiMeta[currentLanguage];
        const formData = new FormData(questionList);
        const submissionPayload = {};
        let hasMissing = false;
        let firstInvalidQuestion = null;

        const markMissing = (question) => {
          if (!hasMissing) {
            firstInvalidQuestion = question.id;
          }
          hasMissing = true;
        };

        questions.forEach((question) => {
          if (question.type === "single") {
            const selectedValue = formData.get(question.id);
            if (!selectedValue) {
              markMissing(question);
              return;
            }
            const option = findOptionByValue(question, selectedValue.toString());
            if (!option) {
              markMissing(question);
              return;
            }
            const entry = { type: "single", selection: selectedValue.toString() };
            if (option.hasTextInput) {
              const extraValue = (formData.get(`${question.id}__${option.value}__text`) || "").toString().trim();
              if (!extraValue) {
                markMissing(question);
                return;
              }
              entry.otherText = extraValue;
            }
            submissionPayload[question.id] = entry;
          } else if (question.type === "multi") {
            const selections = formData.getAll(question.id).map((value) => value.toString());
            if (!selections.length) {
              markMissing(question);
              return;
            }
            const entry = { type: "multi", selections };
            const otherText = {};
            selections.forEach((selected) => {
              const option = findOptionByValue(question, selected);
              if (option?.hasTextInput) {
                const extraValue = (formData.get(`${question.id}__${option.value}__text`) || "").toString().trim();
                if (!extraValue) {
                  markMissing(question);
                } else {
                  otherText[selected] = extraValue;
                }
              }
            });
            if (hasMissing) {
              return;
            }
            if (Object.keys(otherText).length) {
              entry.otherText = otherText;
            }
            submissionPayload[question.id] = entry;
          } else if (question.type === "text") {
            const textValue = (formData.get(question.id) || "").toString().trim();
            if (!textValue) {
              markMissing(question);
              return;
            }
            submissionPayload[question.id] = { type: "text", text: textValue };
          }
        });

        if (hasMissing) {
          if (firstInvalidQuestion) {
            const target = questionList.querySelector(`[data-question-id="${firstInvalidQuestion}"]`);
            target?.scrollIntoView({ behavior: "smooth", block: "center" });
          }
          alert(meta.requiredError);
          return;
        }

        questionList.reset();
        renderPreview();
        alert(meta.submitSuccess);
        switchScreen("stats");
        saveResponseSubmission(submissionPayload).then(() => {
          loadCloudStats();
          loadResponseFeed();
        });
      };

      const updateUIText = () => {
        const copy = contentText[currentLanguage];
        const meta = uiMeta[currentLanguage];
        setText(ui.heroEyebrow, copy.heroEyebrow);
        setText(ui.heroTitle, copy.heroTitle);
        setText(ui.heroDesc, copy.heroDesc);
        setText(ui.previewLabel, copy.previewLabel);
        setText(ui.previewTitle, copy.previewTitle);
        setText(ui.editorLabel, copy.editorLabel);
        setText(ui.editorTitle, copy.editorTitle);
        setText(ui.scrollDownLabel, copy.scrollDown);
        setText(ui.addQuestion, copy.addQuestion);
        setText(ui.submit, copy.submit);
        setText(ui.langToggle, meta.toggle);
        setText(ui.logoLabel, meta.logoLabel);
        setText(ui.logoTitle, meta.logoTitle);
        setText(ui.logoHelper, meta.logoHelper);
        setText(ui.logoUploadText, meta.logoUpload);
        setText(ui.logoResetButton, meta.logoReset);
        setText(ui.qrLabel, meta.qrLabel);
        setText(ui.qrTitle, meta.qrTitle);
        setText(ui.qrHelper, meta.qrHelper);
        setText(ui.qrInputLabel, meta.qrInputLabel);
        setText(ui.qrRefresh, meta.qrRefresh);
        setText(ui.qrNote, meta.qrNote);
        setText(ui.adminButton, meta.adminButton);
        setText(ui.exitAdminButton, meta.exitAdminButton || "");
        setText(ui.saveButton, meta.saveChanges || "");
        setText(ui.builderTab, meta.tabBuilder);
        setText(ui.statsTab, meta.tabStats);
        setText(ui.statsLabel, meta.statsLabel);
        setText(ui.statsTitle, meta.statsTitle);
        setText(ui.statsHelper, meta.statsHelper);
        setText(ui.statsEmpty, meta.statsEmpty);
        setText(ui.responsesLabel, meta.responsesPanelLabel);
        setText(ui.responsesTitle, meta.responsesPanelTitle);
        setText(ui.responsesHelper, meta.responsesHelper);
        setText(ui.responseRefresh, meta.responsesRefresh);
        if (!responseFeedItems.length && !responseFeedLoading) {
          setText(ui.responsesEmpty, meta.responsesEmpty);
        }
        renderStats();
        renderResponseFeedList();
      };

      const loadCloudStats = async () => {
        statsLoading = true;
        statsError = null;
        renderStats();
        try {
          const params = new URLSearchParams({
            select: "answers,submitted_at",
            order: "submitted_at.desc",
            limit: STATS_FETCH_LIMIT.toString()
          });
          const response = await fetch(`${SUPABASE_RESPONSES_ENDPOINT}?${params.toString()}`, {
            headers: supabaseHeaders
          });
          if (!response.ok) {
            throw new Error(`Failed to load cloud stats (${response.status})`);
          }
          const data = await response.json();
          const records = Array.isArray(data) ? data : [];
          cloudTotals = aggregateCloudTotals(records);
          cloudSubmissionCount = records.length;
          cloudLastUpdated = records[0]?.submitted_at || null;
        } catch (error) {
          statsError = error;
        } finally {
          statsLoading = false;
          renderStats();
        }
      };

      if (ui.addQuestion) {
        ui.addQuestion.addEventListener("click", () => {
          const count = questions.length + 1;
          const newId = createId();
          const newQuestion = {
            id: newId,
            sectionId: questionSections[0].id,
            type: "single",
            required: true,
            text: {
              zh: `新问题 ${count}`,
              en: `New question ${count}`
            },
            description: {
              zh: "",
              en: ""
            },
            options: [
              { value: "option-a", label: { zh: "选项 1", en: "Option 1" } },
              { value: "option-b", label: { zh: "选项 2", en: "Option 2" } },
              { value: "option-c", label: { zh: "选项 3", en: "Option 3" } }
            ]
          };
          questions.push(newQuestion);
          renderEditor();
          renderPreview();
          renderStats();
        });
      }

      ui.langToggle.addEventListener("click", () => {
        currentLanguage = currentLanguage === "zh" ? "en" : "zh";
        document.documentElement.lang = currentLanguage === "zh" ? "zh-CN" : "en";
        renderCopyEditor();
        renderEditor();
        renderPreview();
        updateUIText();
      });

      if (ui.builderTab) {
        ui.builderTab.addEventListener("click", () => switchScreen("builder"));
      }

      if (ui.statsTab) {
        ui.statsTab.addEventListener("click", () => switchScreen("stats"));
      }

      if (ui.responseRefresh) {
        ui.responseRefresh.addEventListener("click", () => {
          loadResponseFeed();
        });
      }

      if (ui.submit) {
        ui.submit.addEventListener("click", handleSubmit);
      }

      if (ui.adminButton) {
        ui.adminButton.addEventListener("click", () => {
          const meta = uiMeta[currentLanguage];
          const input = window.prompt(meta.adminPrompt);
          if (input === null) return;
          if (input.trim() === ADMIN_PASSWORD) {
            enableAdminMode();
          } else {
            alert(meta.adminError);
          }
        });
      }

      if (ui.exitAdminButton) {
        ui.exitAdminButton.addEventListener("click", () => {
          disableAdminMode();
        });
      }

      if (ui.saveButton) {
        ui.saveButton.addEventListener("click", async () => {
          const meta = uiMeta[currentLanguage];
          persistQuestions();
          persistContent();
          ui.saveButton.disabled = true;
          try {
            await saveRemoteConfig({ questions, contentText, logoDataUrl: currentLogoDataUrl });
            alert(meta.saveSuccess || "已保存");
          } catch (error) {
            alert(currentLanguage === "zh" ? "保存失败，请稍后再试。" : "Failed to save. Please try again.");
          } finally {
            ui.saveButton.disabled = false;
          }
        });
      }

      if (ui.qrRefresh) {
        ui.qrRefresh.addEventListener("click", updateQrFromInput);
      }

      if (ui.qrUrlInput) {
        ui.qrUrlInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            updateQrFromInput();
          }
        });
      }

      if (ui.logoInput) {
        ui.logoInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          if (file.size > LOGO_MAX_BYTES) {
            alert(currentLanguage === "zh" ? "请选择 2 MB 以下的图片文件。" : "Please choose an image smaller than 2 MB.");
            event.target.value = "";
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = reader.result;
            if (typeof dataUrl === "string") {
              currentLogoDataUrl = dataUrl;
              applyLogoSrc(dataUrl);
              persistLogo(dataUrl);
            }
          };
          reader.onerror = () => {
            alert(currentLanguage === "zh" ? "无法读取文件，请重试。" : "Unable to read the file. Please try again.");
          };
          reader.readAsDataURL(file);
        });
      }

      if (ui.logoResetButton) {
        ui.logoResetButton.addEventListener("click", () => {
          persistLogo(null);
          currentLogoDataUrl = null;
          applyLogoSrc(DEFAULT_LOGO_SRC);
          if (ui.logoInput) {
            ui.logoInput.value = "";
          }
        });
      }

      if (ui.scrollRange && editorList) {
        ui.scrollRange.addEventListener("input", (event) => {
          const maxScroll = editorList.scrollHeight - editorList.clientHeight;
          if (maxScroll <= 0) return;
          const ratio = Number(event.target.value) / 100;
          editorList.scrollTop = ratio * maxScroll;
        });
      }

      if (editorList) {
        editorList.addEventListener("scroll", syncScrollHandle);
        window.addEventListener("resize", syncScrollHandle);
      }

      const bootstrap = async () => {
        let syncedLogo = false;
        try {
          const remoteConfig = await fetchRemoteConfig();
          if (remoteConfig) {
            if (isValidQuestionSet(remoteConfig.questions)) {
              questions = remoteConfig.questions;
              persistQuestions();
            }
            if (remoteConfig.contentText) {
              contentText = remoteConfig.contentText;
              persistContent();
            }
            if (remoteConfig.logoDataUrl) {
              currentLogoDataUrl = remoteConfig.logoDataUrl;
              applyLogoSrc(currentLogoDataUrl);
              persistLogo(currentLogoDataUrl);
              syncedLogo = true;
            }
          }
        } catch (error) {
          console.warn("Unable to load remote config, falling back to local cache");
        }

        if (!syncedLogo) {
          loadStoredLogo();
        }

        initQrSection();

        const searchParams = new URLSearchParams(window.location.search);
        if (searchParams.get("admin") === "1" || sessionStorage.getItem(ADMIN_MODE_KEY) === "true") {
          enableAdminMode();
        } else {
          disableAdminMode();
        }

        renderPreview();
        renderEditor();
        renderCopyEditor();
        renderStats();
        loadCloudStats();
        loadResponseFeed();
        updateUIText();
      };

      bootstrap();
    </script>
  </body>
</html>
