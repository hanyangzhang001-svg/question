<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Survey Builder</title>
    <link rel="icon" type="image/svg+xml" href="./assets/logo.svg" />
    <style>
      :root {
        color-scheme: light;
        --bg: #edf2fb;
        --surface: #ffffff;
        --accent: #6c7ae0;
        --accent-strong: #5661c5;
        --text: #1f2a44;
        --muted: #7c88b0;
        --border: rgba(31, 42, 68, 0.12);
        --soft: rgba(108, 122, 224, 0.08);
        font-family: "Inter", "PingFang SC", "Microsoft YaHei", system-ui,
          -apple-system, BlinkMacSystemFont, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #fdf2ff 0%, #edf4ff 40%, var(--bg) 100%);
        padding: 48px 24px 64px;
        color: var(--text);
      }

      .page {
        max-width: 1180px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 32px;
      }

      .qr-card {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(220px, 0.8fr);
        gap: 32px;
        background: var(--surface);
        border-radius: 28px;
        padding: 32px 40px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.08);
        align-items: center;
      }

      .qr-content h2 {
        margin: 8px 0 12px;
      }

      .qr-helper {
        margin: 0 0 18px;
        color: var(--muted);
        line-height: 1.6;
      }

      .qr-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .qr-form label {
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .qr-form input {
        border-radius: 14px;
        border: 1px solid var(--border);
        padding: 12px 14px;
        font-size: 0.95rem;
      }

      .qr-form input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--soft);
      }

      .qr-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .qr-preview {
        border-radius: 24px;
        border: 1px dashed rgba(108, 122, 224, 0.25);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        justify-content: center;
        background: rgba(247, 249, 255, 0.9);
      }

      .qr-canvas {
        width: 180px;
        height: 180px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .qr-canvas img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .qr-note {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
        text-align: center;
      }

      .page-tabs {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 20px;
        padding: 6px;
        border: 1px solid var(--border);
      }

      .tab-btn {
        flex: 1;
        border: none;
        background: transparent;
        color: var(--muted);
        font-weight: 600;
        padding: 12px 20px;
        border-radius: 16px;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .tab-btn.active {
        background: var(--text);
        color: white;
      }

      .hero {
        display: flex;
        justify-content: space-between;
        gap: 24px;
        align-items: center;
        background: var(--surface);
        border-radius: 28px;
        padding: 32px 40px;
        box-shadow: 0 25px 60px rgba(31, 42, 68, 0.12);
        border: 1px solid var(--border);
      }

      .hero-actions {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: flex-end;
      }

      .hero-brand {
        display: flex;
        align-items: center;
        gap: 24px;
        flex: 1;
      }

      .hero-logo {
        width: 110px;
        max-height: 110px;
        object-fit: contain;
      }

      .hero-copy {
        flex: 1;
      }

      .hero h1 {
        margin: 6px 0 12px;
        font-size: 2rem;
        letter-spacing: -0.02em;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        max-width: 560px;
        line-height: 1.6;
      }

      .eyebrow {
        font-size: 0.85rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--accent-strong);
      }

      .toggle {
        background: rgba(108, 122, 224, 0.1);
        color: var(--accent-strong);
        border: none;
        padding: 12px 20px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
        white-space: nowrap;
      }

      .toggle:hover {
        transform: translateY(-1px);
        background: rgba(108, 122, 224, 0.16);
      }

      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 24px;
      }

      .admin-mode .layout {
        grid-template-columns: minmax(0, 1.1fr) minmax(320px, 0.9fr);
      }

      .panel {
        background: var(--surface);
        border-radius: 28px;
        padding: 32px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.08);
        display: flex;
        flex-direction: column;
        gap: 24px;
        overflow: visible;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: center;
      }

      .panel-actions {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .panel h2 {
        margin: 6px 0 0;
      }

      .ghost {
        background: transparent;
        border: 1px dashed var(--accent);
        color: var(--accent-strong);
        padding: 10px 18px;
        border-radius: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: border 0.2s ease, color 0.2s ease;
      }

      .ghost:hover {
        border-color: var(--accent-strong);
        color: var(--accent-strong);
      }

      .ghost-small {
        padding: 8px 14px;
        border-radius: 12px;
      }

      .scroll-control {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 220px;
      }

      .editor-controls {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .scroll-label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .scroll-range {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--accent) 0%, rgba(108, 122, 224, 0.35) 100%);
        position: relative;
        cursor: pointer;
      }

      .scroll-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--surface);
        border: 2px solid var(--accent);
        box-shadow: 0 4px 15px rgba(31, 42, 68, 0.2);
      }

      .scroll-range::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--surface);
        border: 2px solid var(--accent);
        box-shadow: 0 4px 15px rgba(31, 42, 68, 0.2);
      }

      .scroll-range:disabled {
        cursor: not-allowed;
        opacity: 0.35;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .question {
        padding: 24px 24px 22px;
        border-radius: 22px;
        border: 1px solid rgba(108, 122, 224, 0.15);
        background: linear-gradient(135deg, rgba(108, 122, 224, 0.04), rgba(255, 255, 255, 0.9));
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .question-section {
        margin-bottom: 32px;
      }

      .question-section h3 {
        margin-bottom: 12px;
        font-size: 1.05rem;
        color: var(--accent-strong);
      }

      .question-head {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .question-required {
        font-size: 0.75rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--accent-strong);
      }

      .question-description {
        margin: -8px 0 8px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .survey-intro {
        padding: 20px 24px;
        border-radius: 22px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px dashed rgba(108, 122, 224, 0.35);
        margin-bottom: 12px;
      }

      .survey-intro h2 {
        margin: 0 0 8px;
        font-size: 1.2rem;
      }

      .survey-intro p {
        margin: 6px 0;
        color: var(--muted);
        line-height: 1.6;
      }

      .question-title {
        font-size: 1.05rem;
        margin: 0 0 16px;
        font-weight: 600;
      }

      .options {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .option {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid transparent;
        cursor: pointer;
        transition: border 0.2s ease, transform 0.2s ease;
      }

      .option:hover {
        border-color: rgba(108, 122, 224, 0.4);
        transform: translateY(-1px);
      }

      .option input {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid var(--muted);
        display: grid;
        place-items: center;
        margin: 0;
      }

      .option input::after {
        content: "";
        width: 8px;
        height: 8px;
        background: var(--accent);
        border-radius: 50%;
        transform: scale(0);
        transition: transform 0.15s ease;
      }

      .option input:checked {
        border-color: var(--accent);
      }

      .option input:checked::after {
        transform: scale(1);
      }

      .option input[type="checkbox"] {
        border-radius: 6px;
      }

      .option input[type="checkbox"]::after {
        border-radius: 2px;
      }

      .badge {
        width: 32px;
        height: 32px;
        border-radius: 16px;
        background: rgba(108, 122, 224, 0.15);
        color: var(--accent-strong);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
      }

      .option-text {
        font-size: 0.95rem;
      }

      .option-extra {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 0.9rem;
        margin-top: 6px;
      }

      .submit {
        border: none;
        border-radius: 18px;
        padding: 16px;
        background: linear-gradient(120deg, #6c7ae0, #8da2fb);
        color: white;
        font-size: 1rem;
        letter-spacing: 0.04em;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 18px 35px rgba(108, 122, 224, 0.3);
      }

      .editor-panel {
        gap: 20px;
        display: none;
      }

      .admin-mode .editor-panel {
        display: flex;
      }

      .logo-uploader {
        border: 1px dashed var(--border);
        border-radius: 20px;
        padding: 20px 22px;
        background: rgba(247, 249, 255, 0.84);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .logo-head {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }

      .logo-copy h3 {
        margin: 0;
        font-size: 1rem;
      }

      .logo-helper {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .logo-actions {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }

      .upload-btn {
        border-radius: 14px;
        padding: 10px 18px;
        background: rgba(108, 122, 224, 0.12);
        color: var(--accent-strong);
        font-weight: 600;
        cursor: pointer;
        border: 1px solid transparent;
        transition: transform 0.2s ease, border 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .upload-btn:hover {
        transform: translateY(-1px);
        border-color: rgba(108, 122, 224, 0.5);
      }

      .copy-editor {
        border: 1px dashed var(--border);
        border-radius: 20px;
        padding: 20px 22px;
        background: rgba(247, 249, 255, 0.84);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .copy-head h3 {
        margin: 0;
        font-size: 1rem;
      }

      .copy-helper {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .copy-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px 16px;
      }

      .copy-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.9rem;
      }

      .copy-field textarea {
        min-height: 72px;
        resize: vertical;
      }

      .stats-panel {
        background: var(--surface);
        border-radius: 28px;
        padding: 32px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.06);
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .stats-helper {
        margin: 0;
        color: var(--muted);
      }

      .stats-list {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .stats-card {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 22px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .stats-card h3 {
        margin: 0;
        font-size: 1rem;
      }

      .stats-total {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .stats-option {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 10px 0;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
      }

      .stats-option:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      .stats-section {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .stats-section + .stats-section {
        margin-top: 28px;
      }

      .stats-section h3 {
        margin: 0;
        font-size: 1rem;
        color: var(--accent-strong);
      }

      .stats-text-note {
        margin: 4px 0 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .response-panel {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 22px;
        padding: 24px;
        background: rgba(247, 249, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .response-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .response-helper {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .response-feed {
        display: flex;
        flex-direction: column;
        gap: 14px;
        max-height: 360px;
        overflow-y: auto;
      }

      .response-entry {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 18px;
        padding: 14px 16px;
        background: white;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .response-entry time {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .response-answer {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.55;
      }

      .response-empty {
        margin: 0;
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .option-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.92rem;
      }

      .option-head strong {
        color: var(--accent-strong);
        letter-spacing: 0.08em;
      }

      .progress {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.08);
        overflow: hidden;
      }

      .progress span {
        display: block;
        height: 100%;
        background: linear-gradient(90deg, #6c7ae0, #8da2fb);
      }

      .stats-empty {
        margin: 0;
        padding: 24px;
        text-align: center;
        border-radius: 18px;
        border: 1px dashed var(--border);
        color: var(--muted);
        background: rgba(247, 249, 255, 0.8);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }

      .editor-divider {
        height: 1px;
        width: 100%;
        background: linear-gradient(
          90deg,
          rgba(108, 122, 224, 0),
          rgba(108, 122, 224, 0.35),
          rgba(108, 122, 224, 0)
        );
      }

      .editor-list {
        display: flex;
        flex-direction: column;
        gap: 18px;
        overflow-y: auto;
        padding-right: 4px;
        scroll-behavior: smooth;
        max-height: clamp(280px, 48vh, 520px);
        min-height: 240px;
        border-radius: 16px;
        padding-bottom: 4px;
      }

      .editor-card {
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 20px;
        background: rgba(247, 249, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .editor-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .editor-card header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .remove {
        border: none;
        background: rgba(255, 67, 86, 0.12);
        color: #d8344e;
        border-radius: 12px;
        padding: 6px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      label span {
        font-size: 0.85rem;
        color: var(--muted);
        display: inline-block;
        margin-bottom: 6px;
      }

      textarea,
      input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: white;
        font-size: 0.95rem;
        resize: vertical;
        min-height: 42px;
      }

      textarea {
        min-height: 64px;
      }

      textarea:focus,
      input[type="text"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--soft);
      }

      @media (max-width: 1024px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .editor-panel {
          max-height: none;
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 32px 16px 48px;
        }

        .hero {
          flex-direction: column;
        }

        .hero-brand {
          flex-direction: column;
          align-items: flex-start;
        }

        .hero-actions {
          width: 100%;
          align-items: flex-start;
        }

        .panel {
          padding: 24px;
        }

        .qr-card {
          grid-template-columns: 1fr;
          padding: 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header class="hero">
        <div class="hero-brand">
          <img src="./assets/logo.svg" alt="After Wags logo" class="hero-logo" />
          <div class="hero-copy">
            <p class="eyebrow" id="hero-eyebrow">Live Survey Builder</p>
            <h1 id="hero-title">Pet Toy Sustainability Survey</h1>
            <p id="hero-desc">
              Preview every tweak instantly, share QR links, and collaborate in two languages with a modern, minimal layout.
            </p>
          </div>
        </div>
        <div class="hero-actions">
          <button id="lang-toggle" class="toggle" type="button">åˆ‡æ¢åˆ° English</button>
          <button id="admin-button" class="ghost" type="button">ç®¡ç†å‘˜å…¥å£</button>
          <button id="exit-admin-button" class="ghost" type="button" hidden>é€€å‡ºç®¡ç†å‘˜æ¨¡å¼</button>
        </div>
      </header>

      <section class="qr-card">
        <div class="qr-content">
          <p class="eyebrow" id="qr-label">Scan to open</p>
          <h2 id="qr-title">QR entry point</h2>
          <p class="qr-helper" id="qr-helper">
            Share the survey link to any channel and let people scan to open it instantly. Customize the URL to match your deployment.
          </p>
          <div class="qr-form">
            <label>
              <span id="qr-input-label">Destination URL</span>
              <input id="qr-url" type="url" placeholder="https://example.com/survey" />
            </label>
            <div class="qr-actions">
              <button id="qr-refresh" class="ghost" type="button">Update QR code</button>
            </div>
          </div>
        </div>
        <div class="qr-preview">
          <div id="qr-code" class="qr-canvas" aria-label="äºŒç»´ç "></div>
          <p class="qr-note" id="qr-note">Scan on mobile to open the survey</p>
        </div>
      </section>

      <nav class="page-tabs">
        <button id="tab-builder" class="tab-btn active" type="button">Survey builder</button>
        <button id="tab-stats" class="tab-btn" type="button">Response stats</button>
      </nav>

      <section id="builder-view" class="layout builder-view">
        <div class="panel preview-panel">
          <div class="panel-header">
            <div>
              <p class="eyebrow" id="preview-label">Preview</p>
              <h2 id="preview-title">What participants will see</h2>
            </div>
          </div>

          <form id="question-list" novalidate></form>
          <button id="submit-btn" class="submit" type="button">Submit survey</button>
        </div>

        <div class="panel editor-panel" hidden aria-hidden="true">
          <div class="panel-header">
            <div>
              <p class="eyebrow" id="editor-label">Editor</p>
              <h2 id="editor-title">Update questions & options</h2>
            </div>
            <div class="panel-actions">
              <button id="save-editor" class="toggle" type="button">Save changes</button>
            </div>
          </div>

          <div class="logo-uploader">
            <div class="logo-head">
              <div class="logo-copy">
                <p class="eyebrow" id="logo-label">Brand logo</p>
                <h3 id="logo-title">Upload your own mark</h3>
                <p class="logo-helper" id="logo-helper">
                  Supports PNG / JPG / SVG (â‰¤2MB). Transparent backgrounds work best.
                </p>
              </div>
              <div class="logo-actions">
                <label class="upload-btn">
                  <input id="logo-input" type="file" accept="image/*" hidden />
                  <span id="logo-upload-text">Upload image</span>
                </label>
                <button id="logo-reset" class="ghost-small" type="button">Reset</button>
              </div>
            </div>
          </div>

          <div id="copy-editor" class="copy-editor"></div>

          <div class="editor-divider"></div>
          <div class="editor-controls">
            <div class="scroll-control">
              <span class="scroll-label" id="scroll-editor-label">Drag to scroll questions</span>
              <input
                id="scroll-editor-range"
                class="scroll-range"
                type="range"
                min="0"
                max="100"
                value="0"
              />
            </div>
            <button id="add-question" class="ghost" type="button">Add question</button>
          </div>
          <div id="editor-list" class="editor-list"></div>
        </div>
      </section>

      <section id="stats-view" class="stats-panel" hidden>
        <div class="panel-header">
          <div>
            <p class="eyebrow" id="stats-label">Response stats</p>
            <h2 id="stats-title">Overall answer overview</h2>
          </div>
        </div>
        <p class="stats-helper" id="stats-helper">Track the preference for each option and monitor trends in real time.</p>
        <div id="stats-content" class="stats-list"></div>
        <p id="stats-empty" class="stats-empty" hidden>No submissions yet.</p>
        <div class="response-panel">
          <div class="response-head">
            <div>
              <p class="eyebrow" id="responses-label">Response log</p>
              <h3 id="responses-title">Latest submissions</h3>
            </div>
            <button id="response-refresh" class="ghost-small" type="button">Refresh list</button>
          </div>
          <p class="response-helper" id="responses-helper">
            Pulls the 50 most recent responses from Supabase so you can review open text answers and choices.
          </p>
          <div id="response-feed" class="response-feed"></div>
          <p id="response-empty" class="response-empty">No submissions have been synced yet.</p>
        </div>
      </section>

    </div>

    <script>
      const surveyIntro = {
        zh: {
          title: "ğŸ¾ å® ç‰©ç©å…·æ¶ˆè´¹ä¸å¯æŒç»­æ€åº¦è°ƒæŸ¥é—®å·ï¼ˆZä¸–ä»£å® ç‰©ä¸»äººï¼‰",
          description: [
            "ä½ å¥½ï¼æ„Ÿè°¢ä½ å‚ä¸æœ¬ç ”ç©¶ã€‚æœ¬é—®å·æ—¨åœ¨äº†è§£Zä¸–ä»£å® ç‰©ä¸»äººçš„å® ç‰©ç©å…·æ¶ˆè´¹ä¹ æƒ¯ã€ä½¿ç”¨æƒ…å†µä¸å¯¹å¯æŒç»­è®¾è®¡çš„æ€åº¦ã€‚",
            "æ‰€æœ‰æ•°æ®ä»…ç”¨äºå­¦æœ¯ç ”ç©¶ï¼ŒåŒ¿åæ”¶é›†ï¼Œä¸ä¼šå…¬å¼€ä¸ªäººä¿¡æ¯ã€‚å¡«å†™å¤§çº¦éœ€è¦5åˆ†é’Ÿã€‚"
          ]
        },
        en: {
          title: "ğŸ¾ Pet Toy Consumption & Sustainability Survey (Gen Z Pet Parents)",
          description: [
            "Hello! Thanks for taking the time. This survey explores how Gen Z pet parents shop for toys, use them, and think about sustainable design.",
            "All responses are anonymous, used for academic research only, and take about five minutes to complete."
          ]
        }
      };

      const questionSections = [
        {
          id: "basic",
          zh: { title: "ä¸€ã€åŸºæœ¬ä¿¡æ¯", summary: "äº†è§£å—è®¿è€…ä¸å® ç‰©çš„åŸºç¡€æƒ…å†µã€‚" },
          en: { title: "I. Basic Information", summary: "Learn more about you and your pet family." }
        },
        {
          id: "purchase",
          zh: { title: "äºŒã€è´­ä¹°è¡Œä¸ºä¸åŠ¨æœº", summary: "æ¢ç´¢ä½ çš„è´­ä¹°é¢‘ç‡ã€é¢„ç®—ä¸åŠ¨æœºã€‚" },
          en: { title: "II. Pet Toy Purchasing Behavior & Motivation", summary: "Dive into your purchase frequency, budget, and triggers." }
        },
        {
          id: "usage",
          zh: { title: "ä¸‰ã€ç©å…·ä½¿ç”¨ä¸å¤„ç†", summary: "äº†è§£ç©å…·ä½¿ç”¨å¯¿å‘½ã€æ•°é‡ä¸å¤„ç†æ–¹å¼ã€‚" },
          en: { title: "III. Toy Usage & Disposal Patterns", summary: "Understand how long toys last, how many you own, and what happens when theyâ€™re unused." }
        },
        {
          id: "sustainability",
          zh: { title: "å››ã€å¯æŒç»­è®¤çŸ¥ä¸æ€åº¦", summary: "å…³æ³¨ä½ å¯¹ç¯ä¿å® ç‰©ç”¨å“çš„è®¤çŸ¥ä¸é‡è¦æ€§ã€‚" },
          en: { title: "IV. Awareness & Attitudes Toward Sustainable Pet Products", summary: "Capture your awareness of eco-friendly toys and how important they feel." }
        },
        {
          id: "reuse",
          zh: { title: "äº”ã€å†åˆ©ç”¨ï¼å›æ”¶ï¼æèµ æ€åº¦", summary: "äº†è§£å¯¹ç©å…·å›æ”¶å’Œå†è®¾è®¡æœåŠ¡çš„å…´è¶£ã€‚" },
          en: { title: "V. Attitudes Toward Toy Reuse / Recycling / Donation", summary: "Gauge willingness to join recycle or donation programs." }
        },
        {
          id: "open",
          zh: { title: "å…­ã€å¼€æ”¾å¼é—®é¢˜", summary: "è‡ªç”±åˆ†äº«å¯¹ç©å…·çš„æ›´å¤šçœ‹æ³•ã€‚" },
          en: { title: "VI. Open-Ended Questions", summary: "Share any additional thoughts in your own words." }
        }
      ];

      const uiMeta = {
        zh: {
          toggle: "åˆ‡æ¢åˆ° English",
          remove: "åˆ é™¤",
          questionTitle: (index) => `é—®é¢˜ ${index}`,
          questionPlaceholder: "è¯·è¾“å…¥é¢˜ç›®å†…å®¹",
          notePlaceholder: "ï¼ˆå¯é€‰ï¼‰è¡¥å……è¯´æ˜",
          optionPlaceholder: (index) => `é€‰é¡¹ ${index}`,
          adminButton: "ç®¡ç†å‘˜å…¥å£",
          exitAdminButton: "é€€å‡ºç®¡ç†å‘˜æ¨¡å¼",
          adminPrompt: "è¯·è¾“å…¥ç®¡ç†å‘˜å¯†ç ",
          adminError: "å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•",
          tabBuilder: "é—®å·è®¾è®¡",
          tabStats: "å›ç­”ç»Ÿè®¡",
          statsLabel: "å›ç­”ç»Ÿè®¡",
          statsTitle: "æ•´ä½“å›ç­”æ¦‚è§ˆ",
          statsHelper: "æŸ¥çœ‹æ¯ä¸ªé€‰é¡¹è¢«é€‰æ‹©çš„æ¬¡æ•°ï¼Œè¿½è¸ªä¸åŒé¢˜ç›®çš„å›ç­”è¶‹åŠ¿ã€‚",
          statsEmpty: "è¿˜æ²¡æœ‰ä»»ä½•æäº¤è®°å½•ã€‚",
          submitSuccess: "æäº¤æˆåŠŸï¼Œæ„Ÿè°¢åé¦ˆï¼",
          responsesLabel: (count) => `å…± ${count} ä»½å›ç­”`,
          responsesPanelLabel: "å›ç­”è®°å½•",
          responsesPanelTitle: "æœ€æ–°æäº¤",
          responsesHelper: "è‡ªåŠ¨ä» Supabase è·å–æœ€è¿‘ 50 æ¡å›ç­”ï¼Œæ–¹ä¾¿æŸ¥çœ‹å¼€æ”¾é¢˜æ–‡æœ¬ä¸å…·ä½“é€‰æ‹©ã€‚",
          responsesEmpty: "æš‚æ—¶æ²¡æœ‰å›ç­”è®°å½•ã€‚",
          responsesRefresh: "åˆ·æ–°åˆ—è¡¨",
          responsesLoading: "æ­£åœ¨åŠ è½½æœ€æ–°çš„å›ç­”è®°å½•â€¦",
          responsesError: "æš‚æ—¶æ— æ³•è·å–å›ç­”ï¼Œè¯·ç¨åå†è¯•ã€‚",
          qrLabel: "æ‰«ç ç›´è¾¾",
          qrTitle: "äºŒç»´ç å…¥å£",
          qrHelper: "å°†é—®å·é“¾æ¥åˆ†äº«åˆ°ä»»ä½•æ¸ é“ï¼Œæ‰«ç å³å¯ç›´æ¥æ‰“å¼€å½“å‰é¡µé¢ã€‚å¯è‡ªå®šä¹‰ç½‘å€æ¥åŒ¹é…éƒ¨ç½²åœ°å€ã€‚",
          qrInputLabel: "è·³è½¬é“¾æ¥",
          qrRefresh: "æ›´æ–°äºŒç»´ç ",
          qrNote: "æ‰‹æœºæ‰«ç ç«‹å³æ‰“å¼€é—®å·",
          qrInvalid: "è¯·è¾“å…¥æœ‰æ•ˆçš„ http(s) é“¾æ¥ã€‚",
          logoLabel: "å“ç‰Œ Logo",
          logoTitle: "ä¸Šä¼ è‡ªå®šä¹‰å›¾åƒ",
          logoHelper: "æ”¯æŒ PNG / JPG / SVGï¼ˆâ‰¤2MBï¼‰ï¼Œå»ºè®®é€æ˜èƒŒæ™¯ã€‚",
          logoUpload: "ä¸Šä¼ å›¾ç‰‡",
          logoReset: "æ¢å¤é»˜è®¤",
          copyLabel: "é¡µé¢æ–‡æ¡ˆ",
          copyTitle: "ç¼–è¾‘å±•ç¤ºæ–‡å­—",
          copyHelper: "é’ˆå¯¹å½“å‰è¯­è¨€ç¼–è¾‘æŠ¬å¤´ã€æŒ‰é’®ç­‰æ‰€æœ‰æ˜¾ç¤ºç»™ç”¨æˆ·çš„æ–‡å­—å†…å®¹ã€‚",
          copyFieldLabels: {
            heroEyebrow: "ä¿¡æ¯æ¡",
            heroTitle: "ä¸»æ ‡é¢˜",
            heroDesc: "æè¿° / å¼•è¨€",
            previewLabel: "é¢„è§ˆåŒºæ ‡ç­¾",
            previewTitle: "é¢„è§ˆåŒºå‰¯æ ‡é¢˜",
            editorLabel: "ç¼–è¾‘åŒºæ ‡ç­¾",
            editorTitle: "ç¼–è¾‘åŒºå‰¯æ ‡é¢˜",
            scrollDown: "â€œä¸‹æ»‘æ¡â€æç¤ºæ–‡æ¡ˆ",
            addQuestion: "â€œæ–°å¢é—®é¢˜â€æŒ‰é’®",
            submit: "æäº¤æŒ‰é’®"
          },
          saveChanges: "ä¿å­˜ç¼–è¾‘",
          saveSuccess: "å·²ä¿å­˜åˆ°äº‘ç«¯ï¼Œå¯åœ¨å…¶ä»–è®¾å¤‡ç»§ç»­ç¼–è¾‘ã€‚",
          requiredError: "è¯·å®Œæˆæ‰€æœ‰å¿…ç­”é¢˜ã€‚",
          textQuestionNote: (count) =>
            count ? `å·²æ”¶é›† ${count} æ¡å¼€æ”¾å›ç­”ï¼Œè¯·åœ¨åå°æŸ¥çœ‹è¯¦æƒ…ã€‚` : "ç­‰å¾…ç¬¬ä¸€æ¡å¼€æ”¾å›ç­”ã€‚"
        },
        en: {
          toggle: "Switch to ä¸­æ–‡",
          remove: "Remove",
          questionTitle: (index) => `Question ${index}`,
          questionPlaceholder: "Enter the prompt",
          notePlaceholder: "Optional helper text",
          optionPlaceholder: (index) => `Option ${index}`,
          adminButton: "Admin console",
          exitAdminButton: "Exit admin mode",
          adminPrompt: "Enter the admin password",
          adminError: "Incorrect password. Try again.",
          tabBuilder: "Survey builder",
          tabStats: "Response stats",
          statsLabel: "Response stats",
          statsTitle: "Overall response overview",
          statsHelper: "Track how often each option is chosen to understand response trends.",
          statsEmpty: "No submissions yet.",
          submitSuccess: "Thanks! Your feedback has been recorded.",
          responsesLabel: (count) => `${count} submissions`,
          responsesPanelLabel: "Response log",
          responsesPanelTitle: "Latest submissions",
          responsesHelper: "Pulls the 50 most recent entries from Supabase so you can review open-text answers.",
          responsesEmpty: "No submissions have been synced yet.",
          responsesRefresh: "Refresh list",
          responsesLoading: "Loading the latest submissionsâ€¦",
          responsesError: "Unable to load responses. Please try again later.",
          qrLabel: "Scan to open",
          qrTitle: "QR entry point",
          qrHelper: "Share this survey anywhereâ€”scanning the code opens the link instantly.",
          qrInputLabel: "Destination URL",
          qrRefresh: "Update QR code",
          qrNote: "Scan on mobile to open the survey",
          qrInvalid: "Please enter a valid http(s) link.",
          logoLabel: "Brand Logo",
          logoTitle: "Upload your mark",
          logoHelper: "PNG / JPG / SVG up to 2 MB. Transparent background recommended.",
          logoUpload: "Upload image",
          logoReset: "Reset to default",
          copyLabel: "Page Copy",
          copyTitle: "Edit visible text",
          copyHelper: "Adjust every piece of wording the respondent sees for the current language.",
          copyFieldLabels: {
            heroEyebrow: "Eyebrow / Tagline",
            heroTitle: "Main title",
            heroDesc: "Description",
            previewLabel: "Preview label",
            previewTitle: "Preview subtitle",
            editorLabel: "Editor label",
            editorTitle: "Editor subtitle",
            scrollDown: "\"Scroll handle\" label",
            addQuestion: "\"Add question\" button",
            submit: "Submit button"
          },
          saveChanges: "Save changes",
          saveSuccess: "Saved remotely so you can continue anywhere.",
          requiredError: "Please answer every required question.",
          textQuestionNote: (count) =>
            count
              ? `${count} open responses collected. Check the admin data for details.`
              : "Waiting for the first open response."
        }
      };

      const copyFieldConfig = [
        { id: "heroEyebrow", type: "text" },
        { id: "heroTitle", type: "text" },
        { id: "heroDesc", type: "textarea" },
        { id: "previewLabel", type: "text" },
        { id: "previewTitle", type: "text" },
        { id: "editorLabel", type: "text" },
        { id: "editorTitle", type: "text" },
        { id: "scrollDown", type: "text" },
        { id: "addQuestion", type: "text" },
        { id: "submit", type: "text" }
      ];

      const createId = () =>
        window.crypto?.randomUUID
          ? window.crypto.randomUUID()
          : `q-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;

      const defaultQuestions = [
        {
          id: "basic-age",
          sectionId: "basic",
          type: "single",
          required: true,
          text: { zh: "æ‚¨çš„å¹´é¾„èŒƒå›´", en: "What is your age range?" },
          options: [
            { value: "18-23", label: { zh: "18â€“23", en: "18â€“23" } },
            { value: "23-30", label: { zh: "23â€“30", en: "23â€“30" } },
            { value: "30-36", label: { zh: "30â€“36", en: "30â€“36" } },
            { value: "36-44", label: { zh: "36â€“44", en: "36â€“44" } }
          ]
        },
        {
          id: "basic-gender",
          sectionId: "basic",
          type: "single",
          required: true,
          text: { zh: "æ‚¨çš„æ€§åˆ«", en: "What is your gender?" },
          options: [
            { value: "male", label: { zh: "ç”·", en: "Male" } },
            { value: "female", label: { zh: "å¥³", en: "Female" } },
            { value: "gender-other", label: { zh: "å…¶ä»–ï¼ä¸æ„¿é€éœ²", en: "Other / Prefer not to say" } }
          ]
        },
        {
          id: "basic-occupation",
          sectionId: "basic",
          type: "multi",
          required: true,
          text: { zh: "å½“å‰èŒä¸šï¼èº«ä»½ï¼ˆå¯å¤šé€‰ï¼‰", en: "What is your current occupation or status? (Select all that apply)" },
          options: [
            { value: "student", label: { zh: "å­¦ç”Ÿ", en: "Student" } },
            { value: "fulltime", label: { zh: "å…¨èŒä¸Šç­æ—", en: "Full-time employee" } },
            { value: "freelancer", label: { zh: "è‡ªç”±èŒä¸šè€…", en: "Freelancer" } },
            {
              value: "occupation-other",
              label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" },
              hasTextInput: true,
              placeholder: { zh: "è¯·å¡«å†™", en: "Describe" }
            }
          ]
        },
        {
          id: "basic-pet-type",
          sectionId: "basic",
          type: "multi",
          required: true,
          text: { zh: "æ‚¨çš„å® ç‰©ç±»å‹ä¸æ•°é‡", en: "What type(s) of pets do you have, and how many?" },
          options: [
            { value: "dog", label: { zh: "ç‹—ï¼ˆæ•°é‡ï¼‰", en: "Dog(s):" }, hasTextInput: true, placeholder: { zh: "è¯·è¾“å…¥æ•°é‡", en: "Number of dogs" } },
            { value: "cat", label: { zh: "çŒ«ï¼ˆæ•°é‡ï¼‰", en: "Cat(s):" }, hasTextInput: true, placeholder: { zh: "è¯·è¾“å…¥æ•°é‡", en: "Number of cats" } }
          ]
        },
        {
          id: "basic-pet-role",
          sectionId: "basic",
          type: "single",
          required: true,
          text: { zh: "å® ç‰©åœ¨æ‚¨ç”Ÿæ´»ä¸­çš„åœ°ä½", en: "What is the role/status of your pet(s) in your life?" },
          options: [
            { value: "family", label: { zh: "å®¶äººï¼å­©å­", en: "Family member / child" } },
            { value: "friend", label: { zh: "æœ‹å‹ï¼ä¼´ä¾£", en: "Friend / companion" } },
            { value: "roommate", label: { zh: "å®¤å‹ï¼ç”Ÿæ´»ä¼™ä¼´", en: "Roommate / living partner" } },
            { value: "role-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·æè¿°", en: "Describe" } }
          ]
        },
        {
          id: "basic-self-ref",
          sectionId: "basic",
          type: "single",
          required: true,
          text: { zh: "åœ¨å®¶ä¸­å¯¹è‡ªå·±çš„ç§°å‘¼", en: "At home, how do you usually refer to yourself in relation to your pet?" },
          options: [
            { value: "parent", label: { zh: "å¦ˆå¦ˆï¼çˆ¸çˆ¸", en: "Mom / Dad" } },
            { value: "sibling", label: { zh: "å§å§ï¼å“¥å“¥", en: "Sister / Brother" } },
            { value: "owner", label: { zh: "ä¸»äºº", en: "Owner" } },
            { value: "friend", label: { zh: "æœ‹å‹", en: "Friend" } },
            { value: "self-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Describe" } }
          ]
        },
        {
          id: "purchase-frequency",
          sectionId: "purchase",
          type: "single",
          required: true,
          text: { zh: "æ‚¨å¤šä¹…ä¼šä¸ºå® ç‰©ä¹°ç©å…·ï¼Ÿ", en: "How often do you usually buy toys for your pet?" },
          options: [
            { value: "weekly", label: { zh: "æ¯å‘¨ä¸€æ¬¡ä»¥ä¸Š", en: "More than once a week" } },
            { value: "biweekly", label: { zh: "æ¯ä¸¤å‘¨ä¸€æ¬¡", en: "Once every two weeks" } },
            { value: "monthly-1-2", label: { zh: "æ¯æœˆ 1â€“2 æ¬¡", en: "1â€“2 times per month" } },
            { value: "two-three-months", label: { zh: "æ¯ 2â€“3 ä¸ªæœˆä¸€æ¬¡", en: "Once every 2â€“3 months" } },
            { value: "six-month", label: { zh: "æ¯ 6 ä¸ªæœˆä¸€æ¬¡", en: "Once every 6 months" } },
            { value: "yearly", label: { zh: "ä¸€å¹´ä¸€æ¬¡æˆ–æ›´å°‘", en: "Once a year or less" } },
            { value: "irregular", label: { zh: "ä¸å®šï¼çœ‹å¿ƒæƒ…", en: "Irregular / depends on mood" } }
          ]
        },
        {
          id: "purchase-monthly",
          sectionId: "purchase",
          type: "single",
          required: true,
          text: { zh: "æ‚¨æ¯æœˆåœ¨å® ç‰©ç©å…·ä¸Šçš„èŠ±è´¹ï¼ˆç¾å…ƒï¼‰", en: "Approximately how much do you spend on pet toys per month (USD)?" },
          options: [
            { value: "lt20", label: { zh: "å°‘äº $20", en: "Less than $20" } },
            { value: "20-50", label: { zh: "$20â€“50", en: "$20â€“50" } },
            { value: "50-100", label: { zh: "$50â€“100", en: "$50â€“100" } },
            { value: "100-200", label: { zh: "$100â€“200", en: "$100â€“200" } },
            { value: "gt200", label: { zh: "$200 ä»¥ä¸Š", en: "More than $200" } }
          ]
        },
        {
          id: "purchase-motivation",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "è´­ä¹°ç©å…·çš„ä¸»è¦åŠ¨æœºï¼ˆå¯å¤šé€‰ï¼‰", en: "What are your main motivations for purchasing pet toys? (Select all that apply)" },
          options: [
            { value: "replace", label: { zh: "æ—§ç©å…·æŸåéœ€æ›¿æ¢", en: "My pet breaks old toys and needs replacements" } },
            { value: "social", label: { zh: "ç¤¾äº¤åª’ä½“ï¼ç½‘çº¢ç§è‰", en: "Influenced by social media or influencers" } },
            { value: "holiday", label: { zh: "èŠ‚æ—¥ï¼ç‰¹æ®Šç¤¼ç‰©", en: "Holiday or special-occasion gifts" } },
            { value: "aesthetic", label: { zh: "è§‰å¾—ç©å…·å¯çˆ±ï¼å¥½çœ‹", en: "I find the toys cute / aesthetically pleasing" } },
            { value: "try-new", label: { zh: "æƒ³è®©å® ç‰©å°è¯•æ–°ç©å…·", en: "I want my pet to try something new" } },
            { value: "motivation-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Share another motivation" } }
          ]
        },
        {
          id: "purchase-channel",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "é€šå¸¸åœ¨å“ªäº›æ¸ é“è´­ä¹°ï¼Ÿ", en: "Where do you usually purchase pet toys? (Select all that apply)" },
          options: [
            { value: "ecommerce", label: { zh: "ç”µå•†å¹³å°", en: "E-commerce platforms" } },
            { value: "offline", label: { zh: "çº¿ä¸‹å® ç‰©åº—", en: "Offline pet stores" } },
            { value: "social-platform", label: { zh: "ç¤¾äº¤åª’ä½“å¹³å°", en: "Social media platforms" } },
            { value: "brand-site", label: { zh: "å“ç‰Œå®˜ç½‘", en: "Brand websites" } },
            { value: "channel-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·å¡«å†™", en: "Describe the channel" } }
          ]
        },
        {
          id: "purchase-factors",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "å“ªäº›å› ç´ å½±å“æ‚¨çš„è´­ä¹°æ„æ„¿ï¼Ÿ", en: "What factors affect your willingness to purchase pet toys? (Select all that apply)" },
          options: [
            { value: "price", label: { zh: "ä»·æ ¼å¤ªé«˜", en: "Price is too high" } },
            { value: "aesthetic", label: { zh: "ä¸ç¬¦åˆå®¡ç¾", en: "Does not match my aesthetic" } },
            { value: "lose-interest", label: { zh: "æ‹…å¿ƒå® ç‰©å¾ˆå¿«å¤±å»å…´è¶£", en: "I think my pet will quickly lose interest" } },
            { value: "quality", label: { zh: "è´¨é‡å·®ï¼æ˜“å", en: "Poor quality / breaks easily" } },
            { value: "material", label: { zh: "æè´¨å®‰å…¨ï¼å¼‚å‘³", en: "Concerns about material safety or odor" } },
            { value: "too-many", label: { zh: "å®¶é‡Œå·²ç»å¾ˆå¤šï¼ç±»ä¼¼", en: "Already purchased too many / similar toys at home" } },
            { value: "storage", label: { zh: "ç¼ºä¹æ”¶çº³ç©ºé—´", en: "Lack of storage space" } },
            { value: "trust", label: { zh: "å“ç‰Œï¼å¹¿å‘Šä¸å¯ä¿¡", en: "Distrust of the brand or its advertising" } },
            { value: "factor-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Describe other factor" } }
          ]
        },
        {
          id: "purchase-restraint",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "ä»€ä¹ˆæƒ…å†µä¸‹ä¼šå…‹åˆ¶è´­ä¹°ï¼Ÿ", en: "In what situations do you usually control or restrain your desire to buy toys? (Select all that apply)" },
          options: [
            { value: "spent-too-much", label: { zh: "è§‰å¾—æœ€è¿‘èŠ±å¤ªå¤š", en: "Feeling like Iâ€™ve spent too much recently" } },
            { value: "not-needed", label: { zh: "å® ç‰©å¹¶ä¸çœŸæ­£éœ€è¦", en: "My pet does not truly need a new toy" } },
            { value: "reminded", label: { zh: "è¢«å®¶äººï¼æœ‹å‹æé†’", en: "Reminded by friends/family to spend rationally" } },
            { value: "reviews", label: { zh: "è¯„ä»·ï¼å®ç‰©ä¸å€¼", en: "Product reviews or inspections make it seem not worth it" } },
            { value: "sustainability", label: { zh: "ç¯ä¿ï¼å¯æŒç»­è€ƒè™‘", en: "Environmental or sustainability concerns" } },
            { value: "restraint-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Describe other situation" } }
          ]
        },
        {
          id: "usage-lose-interest",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "å® ç‰©å¤šä¹…ä¼šå¯¹ç©å…·å¤±å»å…´è¶£ï¼Ÿ", en: "On average, how long does it take for your pet to lose interest in a toy?" },
          options: [
            { value: "hours", label: { zh: "å‡ å°æ—¶å†…", en: "Within a few hours" } },
            { value: "days-1-3", label: { zh: "1â€“3 å¤©å†…", en: "Within 1â€“3 days" } },
            { value: "week", label: { zh: "çº¦ 1 å‘¨", en: "About 1 week" } },
            { value: "month", label: { zh: "çº¦ 1 ä¸ªæœˆ", en: "About 1 month" } },
            { value: "three-months", label: { zh: "3 ä¸ªæœˆåä»æ„Ÿå…´è¶£", en: "Still interested after 3 months" } },
            { value: "depends", label: { zh: "è§†ç©å…·ç±»å‹è€Œå®š", en: "Depends on the type of toy" } },
            { value: "unsure", label: { zh: "ä¸ç¡®å®šï¼æœªç•™æ„", en: "Not sure / havenâ€™t noticed" } }
          ]
        },
        {
          id: "usage-damage",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "ç©å…·å¤šä¹…ä¼šæŸåï¼Ÿ", en: "On average, how long does it take for your petâ€™s toys to become damaged?" },
          options: [
            { value: "damage-hours", label: { zh: "å‡ å°æ—¶å†…", en: "Within a few hours" } },
            { value: "damage-days", label: { zh: "1â€“3 å¤©å†…", en: "Within 1â€“3 days" } },
            { value: "damage-week", label: { zh: "çº¦ 1 å‘¨", en: "About 1 week" } },
            { value: "damage-month", label: { zh: "çº¦ 1 ä¸ªæœˆ", en: "About 1 month" } },
            { value: "damage-3months", label: { zh: "3 ä¸ªæœˆåä»å¯ç”¨", en: "Still usable after 3 months" } },
            { value: "damage-depends", label: { zh: "è§†ç©å…·ç±»å‹è€Œå®š", en: "Depends on the type of toy" } },
            { value: "damage-unsure", label: { zh: "ä¸ç¡®å®šï¼æœªç•™æ„", en: "Not sure / havenâ€™t noticed" } }
          ]
        },
        {
          id: "usage-toy-count",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "å® ç‰©ç›®å‰æœ‰å¤šå°‘ä¸ªç©å…·ï¼Ÿ", en: "How many toys does your pet currently have?" },
          options: [
            { value: "1-3", label: { zh: "1â€“3", en: "1â€“3" } },
            { value: "4-6", label: { zh: "4â€“6", en: "4â€“6" } },
            { value: "7-10", label: { zh: "7â€“10", en: "7â€“10" } },
            { value: "10+", label: { zh: "è¶…è¿‡ 10", en: "More than 10" } }
          ]
        },
        {
          id: "usage-favorite-share",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "ç»å¸¸ç©çš„ç©å…·æ¯”ä¾‹", en: "What percentage of the toys does your pet frequently play with?" },
          options: [
            { value: "80plus", label: { zh: "è¶…è¿‡ 80%", en: "Over 80%" } },
            { value: "half", label: { zh: "å¤§çº¦ä¸€åŠ", en: "About half" } },
            { value: "less-half", label: { zh: "ä¸åˆ°ä¸€åŠ", en: "Less than half" } },
            { value: "few-favorites", label: { zh: "åªæœ‰ä¸€ä¸¤ä¸ªæœ€å–œæ¬¢çš„", en: "Only one or two favorites" } }
          ]
        },
        {
          id: "usage-unused",
          sectionId: "usage",
          type: "multi",
          required: true,
          text: { zh: "é—²ç½®ç©å…·é€šå¸¸å¦‚ä½•å¤„ç†ï¼Ÿ", en: "How do you usually handle unused toys? (Select all that apply)" },
          options: [
            { value: "discard", label: { zh: "ä¸¢å¼ƒ", en: "Throw them away" } },
            { value: "store", label: { zh: "æ”¶èµ·æ¥ä¸ç”¨", en: "Store them without using" } },
            { value: "repurpose", label: { zh: "æ”¹é€ æˆå…¶ä»–ç©å…·", en: "Repurpose into other toys" } },
            { value: "clean", label: { zh: "æ¸…æ´—å†ç”¨", en: "Clean and reuse" } },
            { value: "donate", label: { zh: "æèµ ï¼è½¬é€", en: "Give away / donate" } },
            { value: "unused-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Describe other handling" } }
          ]
        },
        {
          id: "usage-damaged",
          sectionId: "usage",
          type: "multi",
          required: true,
          text: { zh: "æŸåç©å…·é€šå¸¸å¦‚ä½•å¤„ç†ï¼Ÿ", en: "How do you usually handle damaged toys? (Select all that apply)" },
          options: [
            { value: "discard", label: { zh: "ä¸¢å¼ƒ", en: "Throw them away" } },
            { value: "store", label: { zh: "æ”¶èµ·æ¥ä¸ç”¨", en: "Store them without using" } },
            { value: "repurpose", label: { zh: "æ”¹é€ æˆå…¶ä»–ç©å…·", en: "Repurpose into other toys" } },
            { value: "clean", label: { zh: "æ¸…æ´—å†ç”¨", en: "Clean and reuse" } },
            { value: "donate", label: { zh: "èµ é€ï¼æèµ ", en: "Give away / donate" } },
            { value: "damaged-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Describe other handling" } }
          ]
        },
        {
          id: "diy-willingness",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "æ˜¯å¦æ„¿æ„ DIY ç©å…·ï¼Ÿ", en: "Are you willing to DIY toys for your pet?" },
          options: [
            { value: "very", label: { zh: "éå¸¸æ„¿æ„ï¼Œå–œæ¬¢åŠ¨æ‰‹", en: "Very willing â€” I enjoy crafting" } },
            { value: "with-guide", label: { zh: "æ„¿æ„ä½†éœ€è¦æ•™ç¨‹", en: "Willing, but only with tutorials/guidance" } },
            { value: "safety", label: { zh: "ä¸å¤ªæ„¿æ„ï¼Œæ‹…å¿ƒå®‰å…¨æˆ–ä¸å–œæ¬¢", en: "Not very willing â€” concerned about safety or pet disliking it" } },
            { value: "not-enjoy", label: { zh: "ä¸å¤ªæ„¿æ„ï¼Œä¸å–œæ¬¢åŠ¨æ‰‹", en: "Not very willing â€” I donâ€™t enjoy crafting" } }
          ]
        },
        {
          id: "diy-comment",
          sectionId: "usage",
          type: "text",
          required: false,
          text: { zh: "å…³äº DIY çš„è¡¥å……ï¼ˆå¯é€‰ï¼‰", en: "Additional comment about DIY (optional)" }
        },
        {
          id: "sustain-awareness",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "æ˜¯å¦å¬è¯´è¿‡å¯æŒç»­å® ç‰©ç”¨å“", en: "Have you heard of â€œsustainable pet productsâ€ or â€œeco-friendly pet toysâ€?" },
          options: [
            { value: "aware", label: { zh: "å¬è¯´å¹¶äº†è§£", en: "Yes, and I understand the concept" } },
            { value: "heard", label: { zh: "å¬è¯´ä½†ä¸äº†è§£", en: "Yes, but I do not understand much about it" } },
            { value: "never", label: { zh: "ä»æœªå¬è¯´", en: "No, never heard of it" } }
          ]
        },
        {
          id: "sustain-importance",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "é€‰æ‹©ç¯ä¿æè´¨çš„é‡è¦æ€§", en: "How important do you think eco-friendly or recyclable materials are when choosing pet toys?" },
          options: [
            { value: "very", label: { zh: "éå¸¸é‡è¦", en: "Very important" } },
            { value: "somewhat", label: { zh: "æ¯”è¾ƒé‡è¦", en: "Somewhat important" } },
            { value: "neutral", label: { zh: "ä¸€èˆ¬", en: "Neutral" } },
            { value: "not-very", label: { zh: "ä¸å¤ªé‡è¦", en: "Not very important" } },
            { value: "not-at-all", label: { zh: "å®Œå…¨ä¸é‡è¦", en: "Not important at all" } }
          ]
        },
        {
          id: "sustain-premium",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "å¦‚æœè´µ 20% æ˜¯å¦æ„¿æ„è´­ä¹°ï¼Ÿ", en: "If eco-friendly pet toys cost 20% more than regular ones, would you be willing to purchase them?" },
          options: [
            { value: "yes", label: { zh: "ä¼š", en: "Yes" } },
            { value: "depends", label: { zh: "è§†æƒ…å†µè€Œå®š", en: "Depends on the situation" } },
            { value: "no", label: { zh: "ä¸ä¼š", en: "No" } }
          ]
        },
        {
          id: "reuse-participation",
          sectionId: "reuse",
          type: "single",
          required: true,
          text: { zh: "æä¾›å›æ”¶/ç¿»æ–°/æèµ æœåŠ¡ä¼šå‚ä¸å—ï¼Ÿ", en: "If a brand or platform offered toy recycling, refurbishing, or donation services, would you participate?" },
          options: [
            { value: "definitely", label: { zh: "ä¸€å®šä¼š", en: "Definitely" } },
            { value: "probably", label: { zh: "å¯èƒ½ä¼š", en: "Probably" } },
            { value: "depends", label: { zh: "è§†æƒ…å†µ", en: "Depends" } },
            { value: "no", label: { zh: "ä¸ä¼š", en: "No" } }
          ]
        },
        {
          id: "reuse-factors",
          sectionId: "reuse",
          type: "multi",
          required: true,
          text: { zh: "å“ªäº›å› ç´ å½±å“æ‚¨å‚ä¸å›æ”¶ï¼Ÿ", en: "What factors influence your willingness to participate in toy reuse programs? (Select all that apply)" },
          options: [
            { value: "convenience", label: { zh: "ä¾¿åˆ©æ€§", en: "Convenience (drop-off points)" } },
            { value: "hygiene", label: { zh: "å«ç”Ÿä¸å®‰å…¨", en: "Hygiene and safety" } },
            { value: "quantity", label: { zh: "å®¶ä¸­é—²ç½®æ•°é‡", en: "Number of unused toys at home" } },
            { value: "fee", label: { zh: "æœåŠ¡è´¹ç”¨", en: "Service fees" } },
            { value: "trust", label: { zh: "å¯¹æœºæ„çš„ä¿¡ä»»", en: "Trust in the organization" } },
            { value: "rewards", label: { zh: "å¥–åŠ±æˆ–ä¼˜æƒ ", en: "Rewards or incentives" } },
            { value: "responsibility", label: { zh: "ç¯ä¿ï¼ç¤¾ä¼šè´£ä»»æ„Ÿ", en: "Environmental or social responsibility awareness" } },
            { value: "reuse-other", label: { zh: "å…¶ä»–ï¼ˆè¯·æ³¨æ˜ï¼‰", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "è¯·è¡¥å……", en: "Share another factor" } }
          ]
        },
        {
          id: "reuse-redesign",
          sectionId: "reuse",
          type: "single",
          required: true,
          text: { zh: "æ—§ç©å…·å†è®¾è®¡ä¼šè€ƒè™‘ä½¿ç”¨å—ï¼Ÿ", en: "If old toys were redesigned, would you consider using or purchasing them?" },
          options: [
            { value: "very", label: { zh: "éå¸¸æ„¿æ„", en: "Very willing" } },
            { value: "some", label: { zh: "æœ‰ç‚¹å…´è¶£", en: "Somewhat interested" } },
            { value: "not-much", label: { zh: "ä¸å¤ªæ„¿æ„", en: "Not very willing" } },
            { value: "not-at-all", label: { zh: "å®Œå…¨æ²¡å…´è¶£", en: "Not interested at all" } }
          ]
        },
        {
          id: "open-waste",
          sectionId: "open",
          type: "text",
          required: true,
          text: { zh: "å“ªäº›æ–¹é¢æœ€æµªè´¹æˆ–ä¸ç¯ä¿ï¼Ÿ", en: "In your opinion, what aspects of current pet toys are the most wasteful or unsustainable?" }
        },
        {
          id: "open-innovation",
          sectionId: "open",
          type: "text",
          required: true,
          text: { zh: "å¸Œæœ›çœ‹åˆ°å“ªäº›æ”¹è¿›æˆ–åˆ›æ–°ï¼Ÿ", en: "What improvements or innovations would you like to see in future pet toys?" }
        },
        {
          id: "open-diy-barrier",
          sectionId: "open",
          type: "text",
          required: true,
          text: { zh: "ç›®å‰é˜»æ­¢æ‚¨ DIY çš„åŸå› ", en: "What currently discourages you the most from DIY-ing pet toys?" }
        }
      ];

      const defaultContent = {
        zh: {
          heroEyebrow: "Live Survey Builder",
          heroTitle: "å® ç‰©ç©å…·ä¸å¯æŒç»­é—®å·",
          heroDesc:
            "æ”¯æŒé•¿åˆ—è¡¨é¢˜ç›®ã€ä¸­è‹±æ–‡åˆ‡æ¢ã€äºŒç»´ç åˆ†äº«ä¸äº‘ç«¯ä¿å­˜ï¼Œå¸®åŠ©å›¢é˜Ÿéšæ—¶è”åˆä½œä¸šã€å®æ—¶å‘å¸ƒæ›´æ–°ã€‚",
          previewLabel: "é—®å·é¢„è§ˆ",
          previewTitle: "å—è®¿è€…çœ‹åˆ°çš„æ ·å­",
          editorLabel: "ç¼–è¾‘åŒº",
          editorTitle: "å®æ—¶æ›´æ–°é—®é¢˜ä¸é€‰é¡¹",
          scrollDown: "æ‹–åŠ¨æ»‘æ¡æŸ¥çœ‹æ›´å¤šé—®é¢˜",
          addQuestion: "æ–°å¢é—®é¢˜",
          submit: "æäº¤é—®å·"
        },
        en: {
          heroEyebrow: "Live Survey Builder",
          heroTitle: "Pet Toy Sustainability Survey",
          heroDesc:
            "Manage a bilingual questionnaire with live preview, QR sharing, and collaborative cloud saves for the whole team.",
          previewLabel: "Preview",
          previewTitle: "What participants will see",
          editorLabel: "Editor",
          editorTitle: "Update questions & options",
          scrollDown: "Drag to scroll questions",
          addQuestion: "Add question",
          submit: "Submit survey"
        }
      };

      const DEFAULT_LOGO_SRC = "./assets/logo.svg";
      const LOGO_STORAGE_KEY = "survey-builder-logo";
      const LOGO_MAX_BYTES = 2 * 1024 * 1024;
      const QR_URL_STORAGE_KEY = "survey-builder-qr-url";
      const DEFAULT_QR_URL = "https://hanyangzhang001-svg.github.io/HANYANG/";
      const ADMIN_PASSWORD = "123456";
      const ADMIN_MODE_KEY = "survey-builder-admin-mode";
      const STORAGE_QUESTIONS_KEY = "survey-builder-questions";
      const STORAGE_CONTENT_KEY = "survey-builder-content";
      const REMOTE_SYNC_ENABLED = true;
      const RESPONSE_FETCH_LIMIT = 50;
      const STATS_FETCH_LIMIT = 500;
      const SUPABASE_URL = "https://tgckygkqjdihvdazqwqe.supabase.co";
      const SUPABASE_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRnY2t5Z2txamRpaHZkYXpxd3FlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4OTc1MjksImV4cCI6MjA3ODQ3MzUyOX0.GKcnJIL3Ffyj9HljHJqeWObuFOFImnUbCY5rZ8V9BHw";
      const SUPABASE_CONFIG_ENDPOINT = `${SUPABASE_URL}/rest/v1/survey_configs`;
      const SUPABASE_RESPONSES_ENDPOINT = `${SUPABASE_URL}/rest/v1/survey_responses`;
      const SUPABASE_CONFIG_ID = "main";

      const persistQuestions = () => {
        try {
          localStorage.setItem(STORAGE_QUESTIONS_KEY, JSON.stringify(questions));
        } catch (error) {
          console.warn("Unable to store questions", error);
        }
      };

      const persistContent = () => {
        try {
          localStorage.setItem(STORAGE_CONTENT_KEY, JSON.stringify(contentText));
        } catch (error) {
          console.warn("Unable to store content text", error);
        }
      };

      const supabaseHeaders = {
        apikey: SUPABASE_KEY,
        Authorization: `Bearer ${SUPABASE_KEY}`,
        "Content-Type": "application/json"
      };

      const fetchRemoteConfig = async () => {
        if (!REMOTE_SYNC_ENABLED) {
          return null;
        }
        try {
          const response = await fetch(
            `${SUPABASE_CONFIG_ENDPOINT}?id=eq.${SUPABASE_CONFIG_ID}&select=config`,
            {
              headers: supabaseHeaders
            }
          );
          if (!response.ok) throw new Error("Failed to fetch remote config");
          const data = await response.json();
          return data[0]?.config || null;
        } catch (error) {
          console.warn("Unable to fetch remote config", error);
          return null;
        }
      };

      const saveRemoteConfig = async (payload) => {
        if (!REMOTE_SYNC_ENABLED) {
          return null;
        }
        try {
          const response = await fetch(SUPABASE_CONFIG_ENDPOINT, {
            method: "POST",
            headers: { ...supabaseHeaders, Prefer: "resolution=merge-duplicates" },
            body: JSON.stringify({
              id: SUPABASE_CONFIG_ID,
              config: payload,
              updated_at: new Date().toISOString()
            })
          });
          if (!response.ok) throw new Error("Failed to save remote config");
          const raw = await response.text();
          if (!raw) {
            return null;
          }
          return JSON.parse(raw);
        } catch (error) {
          console.error("Unable to save remote config", error);
          throw error;
        }
      };

      const saveResponseSubmission = async (answers) => {
        try {
          await fetch(SUPABASE_RESPONSES_ENDPOINT, {
            method: "POST",
            headers: supabaseHeaders,
            body: JSON.stringify({
              answers,
              submitted_at: new Date().toISOString()
            })
          });
        } catch (error) {
          console.warn("Unable to persist response", error);
        }
      };

      const loadStoredQrUrl = () => {
        try {
          return localStorage.getItem(QR_URL_STORAGE_KEY);
        } catch (error) {
          console.warn("Unable to load QR url", error);
          return null;
        }
      };

      const persistQrUrl = (url) => {
        try {
          localStorage.setItem(QR_URL_STORAGE_KEY, url);
        } catch (error) {
          console.warn("Unable to store QR url", error);
        }
      };

      let currentLanguage = "en";
      let currentScreen = "builder";
      const loadSavedQuestions = () => {
        try {
          const stored = localStorage.getItem(STORAGE_QUESTIONS_KEY);
          if (!stored) return null;
          const parsed = JSON.parse(stored);
          return Array.isArray(parsed) && parsed.length ? parsed : null;
        } catch (error) {
          console.warn("Unable to load saved questions", error);
          return null;
        }
      };

      const loadSavedContent = () => {
        try {
          const stored = localStorage.getItem(STORAGE_CONTENT_KEY);
          if (!stored) return null;
          const parsed = JSON.parse(stored);
          if (!parsed || typeof parsed !== "object") return null;
          return parsed;
        } catch (error) {
          console.warn("Unable to load saved content", error);
          return null;
        }
      };

      const findSectionById = (sectionId) => questionSections.find((section) => section.id === sectionId);

      const findOptionByValue = (question, value) =>
        question?.options?.find((option) => option.value === value);

      const isValidQuestionSet = (list) =>
        Array.isArray(list) &&
        list.every(
          (item) =>
            typeof item === "object" &&
            item !== null &&
            item.id &&
            item.sectionId &&
            item.type &&
            item.text
        );

      const findQuestionById = (id) => questions.find((question) => question.id === id);

      let questions = loadSavedQuestions();
      if (!isValidQuestionSet(questions)) {
        questions = JSON.parse(JSON.stringify(defaultQuestions));
      }
      let contentText = loadSavedContent() || JSON.parse(JSON.stringify(defaultContent));
      let currentLogoDataUrl = null;
      let currentQrUrl = "";
      let adminEnabled = false;
      let responseFeedItems = [];
      let responseFeedLoading = false;
      let responseFeedError = null;
      let statsLoading = false;
      let statsError = null;
      let cloudTotals = {};
      let cloudSubmissionCount = 0;
      let cloudLastUpdated = null;

      const ui = {
        logoImage: document.querySelector(".hero-logo"),
        heroEyebrow: document.getElementById("hero-eyebrow"),
        heroTitle: document.getElementById("hero-title"),
        heroDesc: document.getElementById("hero-desc"),
        previewLabel: document.getElementById("preview-label"),
        previewTitle: document.getElementById("preview-title"),
        editorLabel: document.getElementById("editor-label"),
        editorTitle: document.getElementById("editor-title"),
        logoLabel: document.getElementById("logo-label"),
        logoTitle: document.getElementById("logo-title"),
        logoHelper: document.getElementById("logo-helper"),
        logoUploadText: document.getElementById("logo-upload-text"),
        logoResetButton: document.getElementById("logo-reset"),
        logoInput: document.getElementById("logo-input"),
        scrollDownLabel: document.getElementById("scroll-editor-label"),
        scrollRange: document.getElementById("scroll-editor-range"),
        addQuestion: document.getElementById("add-question"),
        submit: document.getElementById("submit-btn"),
        langToggle: document.getElementById("lang-toggle"),
        builderTab: document.getElementById("tab-builder"),
        statsTab: document.getElementById("tab-stats"),
        builderView: document.getElementById("builder-view"),
        statsView: document.getElementById("stats-view"),
        statsLabel: document.getElementById("stats-label"),
        statsTitle: document.getElementById("stats-title"),
        statsHelper: document.getElementById("stats-helper"),
        statsContent: document.getElementById("stats-content"),
        statsEmpty: document.getElementById("stats-empty"),
        responsesLabel: document.getElementById("responses-label"),
        responsesTitle: document.getElementById("responses-title"),
        responsesHelper: document.getElementById("responses-helper"),
        responsesEmpty: document.getElementById("response-empty"),
        responsesFeed: document.getElementById("response-feed"),
        responseRefresh: document.getElementById("response-refresh"),
        editorPanel: document.querySelector(".editor-panel"),
        qrLabel: document.getElementById("qr-label"),
        qrTitle: document.getElementById("qr-title"),
        qrHelper: document.getElementById("qr-helper"),
        qrInputLabel: document.getElementById("qr-input-label"),
        qrRefresh: document.getElementById("qr-refresh"),
        qrNote: document.getElementById("qr-note"),
        qrUrlInput: document.getElementById("qr-url"),
        qrCode: document.getElementById("qr-code"),
        adminButton: document.getElementById("admin-button"),
        exitAdminButton: document.getElementById("exit-admin-button"),
        saveButton: document.getElementById("save-editor")
      };

      const questionList = document.getElementById("question-list");
      const editorList = document.getElementById("editor-list");
      const copyEditor = document.getElementById("copy-editor");

      const isValidUrl = (value) => {
        if (!value) return false;
        try {
          const parsed = new URL(value);
          return parsed.protocol === "http:" || parsed.protocol === "https:";
        } catch (error) {
          return false;
        }
      };

      const renderQrCode = (value) => {
        if (!ui.qrCode) return;
        const img = document.createElement("img");
        img.alt = "äºŒç»´ç ";
        img.width = 180;
        img.height = 180;
        img.src = `https://quickchart.io/qr?size=220&text=${encodeURIComponent(value)}`;
        img.referrerPolicy = "no-referrer";
        ui.qrCode.innerHTML = "";
        ui.qrCode.appendChild(img);
        currentQrUrl = value;
      };

      const initQrSection = () => {
        if (!ui.qrUrlInput) return;
        const stored = loadStoredQrUrl();
        const initialUrl =
          stored && isValidUrl(stored) ? stored : DEFAULT_QR_URL || window.location.href;
        ui.qrUrlInput.value = initialUrl;
        persistQrUrl(initialUrl);
        renderQrCode(initialUrl);
      };

      const updateQrFromInput = () => {
        if (!ui.qrUrlInput) return;
        const url = ui.qrUrlInput.value.trim();
        const meta = uiMeta[currentLanguage];
        if (!isValidUrl(url)) {
          alert(meta.qrInvalid);
          ui.qrUrlInput.focus();
          return;
        }
        persistQrUrl(url);
        renderQrCode(url);
      };

      const enableAdminMode = () => {
        if (adminEnabled) return;
        adminEnabled = true;
        document.body.classList.add("admin-mode");
        if (ui.editorPanel) {
          ui.editorPanel.hidden = false;
          ui.editorPanel.setAttribute("aria-hidden", "false");
        }
        if (ui.exitAdminButton) {
          ui.exitAdminButton.hidden = false;
        }
        sessionStorage.setItem(ADMIN_MODE_KEY, "true");
        const url = new URL(window.location.href);
        url.searchParams.set("admin", "1");
        window.history.replaceState({}, "", url.toString());
      };

      const disableAdminMode = () => {
        adminEnabled = false;
        document.body.classList.remove("admin-mode");
        if (ui.editorPanel) {
          ui.editorPanel.hidden = true;
          ui.editorPanel.setAttribute("aria-hidden", "true");
        }
        if (ui.exitAdminButton) {
          ui.exitAdminButton.hidden = true;
        }
        sessionStorage.removeItem(ADMIN_MODE_KEY);
        const url = new URL(window.location.href);
        url.searchParams.delete("admin");
        window.history.replaceState({}, "", url.toString());
      };

      const setText = (el, value) => {
        if (el) {
          el.textContent = value;
        }
      };

      const applyLogoSrc = (src) => {
        if (ui.logoImage) {
          ui.logoImage.src = src || DEFAULT_LOGO_SRC;
        }
      };

      const formatTimestamp = (value) => {
        if (!value) return "";
        try {
          const date = new Date(value);
          return new Intl.DateTimeFormat(currentLanguage === "zh" ? "zh-CN" : "en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit"
          }).format(date);
        } catch (error) {
          return value;
        }
      };

      const describeAnswer = (question, answerPayload) => {
        if (!question) {
          return typeof answerPayload === "string" ? answerPayload : "";
        }
        if (answerPayload === null || answerPayload === undefined) {
          return "";
        }
        if (typeof answerPayload === "string") {
          const option = findOptionByValue(question, answerPayload);
          return option?.label?.[currentLanguage] || answerPayload;
        }
        if (Array.isArray(answerPayload)) {
          return answerPayload
            .map((value) => findOptionByValue(question, value)?.label?.[currentLanguage] || value)
            .join(" / ");
        }
        switch (answerPayload.type) {
          case "single": {
            const option = findOptionByValue(question, answerPayload.selection);
            let textValue = option?.label?.[currentLanguage] || answerPayload.selection || "";
            if (answerPayload.otherText) {
              textValue += currentLanguage === "zh" ? `ï¼ˆè¡¥å……ï¼š${answerPayload.otherText}ï¼‰` : ` (note: ${answerPayload.otherText})`;
            }
            return textValue;
          }
          case "multi": {
            const selections = Array.isArray(answerPayload.selections) ? answerPayload.selections : [];
            const pieces = selections.map((value) => {
              const option = findOptionByValue(question, value);
              let label = option?.label?.[currentLanguage] || value;
              const extra = answerPayload.otherText?.[value];
              if (extra) {
                label += currentLanguage === "zh" ? `ï¼ˆè¡¥å……ï¼š${extra}ï¼‰` : ` (note: ${extra})`;
              }
              return label;
            });
            return pieces.join(" / ");
          }
          case "text":
            return answerPayload.text || "";
          default:
            return JSON.stringify(answerPayload);
        }
      };

      const aggregateCloudTotals = (records) => {
        const totals = {};
        records.forEach((record) => {
          const answers = record.answers || {};
          Object.entries(answers).forEach(([questionId, payload]) => {
            const question = questions.find((item) => item.id === questionId);
            if (!question || !payload) return;
            if (question.type === "single") {
              totals[questionId] = totals[questionId] || {};
              const selection = payload.selection;
              if (!selection) return;
              totals[questionId][selection] = (totals[questionId][selection] || 0) + 1;
            } else if (question.type === "multi") {
              totals[questionId] = totals[questionId] || {};
              (payload.selections || []).forEach((selection) => {
                totals[questionId][selection] = (totals[questionId][selection] || 0) + 1;
              });
            }
          });
        });
        return totals;
      };

      const loadStoredLogo = () => {
        try {
          const stored = localStorage.getItem(LOGO_STORAGE_KEY);
          if (stored) {
            currentLogoDataUrl = stored;
            applyLogoSrc(stored);
            return;
          }
        } catch (error) {
          console.warn("Unable to read stored logo", error);
        }
        currentLogoDataUrl = null;
        applyLogoSrc(DEFAULT_LOGO_SRC);
      };

      const persistLogo = (dataUrl) => {
        try {
          if (dataUrl) {
            localStorage.setItem(LOGO_STORAGE_KEY, dataUrl);
          } else {
            localStorage.removeItem(LOGO_STORAGE_KEY);
          }
        } catch (error) {
          console.warn("Unable to persist logo", error);
        }
      };

      const syncScrollHandle = () => {
        if (!editorList || !ui.scrollRange) return;
        const maxScroll = editorList.scrollHeight - editorList.clientHeight;
        const disabled = maxScroll <= 2;
        ui.scrollRange.disabled = disabled;
        if (disabled) {
          ui.scrollRange.value = 0;
          return;
        }
        const progress = (editorList.scrollTop / maxScroll) * 100;
        ui.scrollRange.value = progress;
      };

      const createQuestionElement = (question) => {
        const block = document.createElement("article");
        block.className = "question";
        block.dataset.questionId = question.id;

        const head = document.createElement("div");
        head.className = "question-head";
        const title = document.createElement("h3");
        title.className = "question-title";
        title.textContent = question.text?.[currentLanguage] || "";
        head.appendChild(title);
        if (question.required) {
          const required = document.createElement("span");
          required.className = "question-required";
          required.textContent = currentLanguage === "zh" ? "å¿…ç­”" : "Required";
          head.appendChild(required);
        }
        block.appendChild(head);

        const descriptionText = question.description?.[currentLanguage];
        if (descriptionText) {
          const description = document.createElement("p");
          description.className = "question-description";
          description.textContent = descriptionText;
          block.appendChild(description);
        }

        if (question.type === "text") {
          const textarea = document.createElement("textarea");
          textarea.name = question.id;
          textarea.required = Boolean(question.required);
          textarea.placeholder = question.placeholder?.[currentLanguage] || "";
          textarea.rows = question.longAnswer ? 4 : 3;
          block.appendChild(textarea);
          return block;
        }

        const optionsWrap = document.createElement("div");
        optionsWrap.className = "options";
        (question.options || []).forEach((option, index) => {
          const label = document.createElement("label");
          label.className = "option";

          const input = document.createElement("input");
          input.type = question.type === "multi" ? "checkbox" : "radio";
          input.name = question.id;
          input.value = option.value;
          if (question.type === "single" && question.required) {
            input.required = true;
          }

          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = index + 1;

          const optionText = document.createElement("span");
          optionText.className = "option-text";
          optionText.textContent = option.label?.[currentLanguage] || "";

          label.appendChild(input);
          label.appendChild(badge);
          label.appendChild(optionText);

          if (option.hasTextInput) {
            const extraInput = document.createElement("input");
            extraInput.type = "text";
            extraInput.className = "option-extra";
            extraInput.name = `${question.id}__${option.value}__text`;
            extraInput.placeholder = option.placeholder?.[currentLanguage] || "";
            extraInput.disabled = true;
            label.appendChild(extraInput);
            const syncExtraInput = () => {
              const active = question.type === "multi" ? input.checked : input.checked;
              extraInput.disabled = !active;
              extraInput.required = active;
              if (!active) {
                extraInput.value = "";
              }
            };
            input.addEventListener("change", syncExtraInput);
          }

          optionsWrap.appendChild(label);
        });
        block.appendChild(optionsWrap);
        return block;
      };

      const renderPreview = () => {
        if (!questionList) return;
        questionList.innerHTML = "";

        const intro = surveyIntro[currentLanguage];
        if (intro) {
          const introBlock = document.createElement("section");
          introBlock.className = "survey-intro";
          const introTitle = document.createElement("h2");
          introTitle.textContent = intro.title;
          introBlock.appendChild(introTitle);
          intro.description?.forEach((paragraph) => {
            const p = document.createElement("p");
            p.textContent = paragraph;
            introBlock.appendChild(p);
          });
          questionList.appendChild(introBlock);
        }

        questionSections.forEach((section) => {
          const sectionQuestions = questions.filter((question) => question.sectionId === section.id);
          if (!sectionQuestions.length) return;
          const sectionBlock = document.createElement("div");
          sectionBlock.className = "question-section";
          const heading = document.createElement("h3");
          heading.textContent = section[currentLanguage].title;
          sectionBlock.appendChild(heading);
          const summary = section[currentLanguage].summary;
          if (summary) {
            const summaryNode = document.createElement("p");
            summaryNode.className = "question-description";
            summaryNode.textContent = summary;
            sectionBlock.appendChild(summaryNode);
          }
          sectionQuestions.forEach((question) => {
            sectionBlock.appendChild(createQuestionElement(question));
          });
          questionList.appendChild(sectionBlock);
        });
      };

      const renderEditor = () => {
        if (!editorList) return;
        const meta = uiMeta[currentLanguage];
        editorList.innerHTML = "";
        questions.forEach((question, index) => {
          question.text = question.text || { zh: "", en: "" };
          question.description = question.description || { zh: "", en: "" };
          const card = document.createElement("article");
          card.className = "editor-card";

          const head = document.createElement("header");
          const title = document.createElement("h3");
          const sectionTitle = findSectionById(question.sectionId)?.[currentLanguage]?.title || "";
          title.textContent = `${meta.questionTitle(index + 1)} Â· ${sectionTitle}`;

          const removeButton = document.createElement("button");
          removeButton.className = "remove";
          removeButton.type = "button";
          removeButton.textContent = meta.remove;
          removeButton.addEventListener("click", () => {
            questions = questions.filter((item) => item.id !== question.id);
            renderEditor();
            renderPreview();
            renderStats();
          });

          head.appendChild(title);
          head.appendChild(removeButton);
          card.appendChild(head);

          const questionLabel = document.createElement("label");
          const questionSpan = document.createElement("span");
          questionSpan.textContent = meta.questionPlaceholder;
          const questionInput = document.createElement("textarea");
          questionInput.value = question.text[currentLanguage] || "";
          questionInput.addEventListener("input", (event) => {
            question.text[currentLanguage] = event.target.value;
            renderPreview();
            renderStats();
          });
          questionLabel.appendChild(questionSpan);
          questionLabel.appendChild(questionInput);
          card.appendChild(questionLabel);

          const noteLabel = document.createElement("label");
          const noteSpan = document.createElement("span");
          noteSpan.textContent = meta.notePlaceholder;
          const noteInput = document.createElement("input");
          noteInput.type = "text";
          noteInput.value = question.description[currentLanguage] || "";
          noteInput.placeholder = meta.notePlaceholder;
          noteInput.addEventListener("input", (event) => {
            question.description[currentLanguage] = event.target.value;
            renderPreview();
          });
          noteLabel.appendChild(noteSpan);
          noteLabel.appendChild(noteInput);
          card.appendChild(noteLabel);

          if (Array.isArray(question.options)) {
            question.options.forEach((option, optionIndex) => {
              option.label = option.label || { zh: "", en: "" };
              const optionLabel = document.createElement("label");
              const labelSpan = document.createElement("span");
              labelSpan.textContent = meta.optionPlaceholder(optionIndex + 1);
              const optionInput = document.createElement("input");
              optionInput.type = "text";
              optionInput.value = option.label[currentLanguage] || "";
              optionInput.addEventListener("input", (event) => {
                option.label[currentLanguage] = event.target.value;
                renderPreview();
                renderStats();
              });
              optionLabel.appendChild(labelSpan);
              optionLabel.appendChild(optionInput);
              card.appendChild(optionLabel);
            });
          }

          editorList.appendChild(card);
        });

        syncScrollHandle();
      };

      const renderStats = () => {
        if (!ui.statsContent) return;
        const meta = uiMeta[currentLanguage];
        if (statsLoading) {
          const loadingText = currentLanguage === "zh" ? "äº‘ç«¯ç»Ÿè®¡åŠ è½½ä¸­â€¦" : "Syncing latest dataâ€¦";
          ui.statsContent.innerHTML = `<p class="loader">${loadingText}</p>`;
          if (ui.statsHelper) {
            ui.statsHelper.textContent = meta.statsHelper;
          }
          ui.statsEmpty.hidden = true;
          return;
        }
        if (statsError) {
          ui.statsContent.innerHTML = `<p class="error">${statsError.message || "Unable to load cloud stats"}</p>`;
          if (ui.statsHelper) {
            ui.statsHelper.textContent = meta.statsHelper;
          }
          return;
        }
        if (ui.statsHelper) {
          ui.statsHelper.textContent = cloudLastUpdated
            ? `${meta.statsHelper} Â· Last synced ${formatTimestamp(cloudLastUpdated)}`
            : meta.statsHelper;
        }
        if (!cloudSubmissionCount) {
          ui.statsContent.innerHTML = "";
          if (ui.statsEmpty) {
            ui.statsEmpty.hidden = false;
            ui.statsEmpty.textContent = meta.statsEmpty;
          }
          return;
        }
        if (ui.statsEmpty) {
          ui.statsEmpty.hidden = true;
        }
        ui.statsContent.innerHTML = "";
        questionSections.forEach((section) => {
          const sectionQuestions = questions.filter((question) => question.sectionId === section.id);
          if (!sectionQuestions.length) return;
          const sectionBlock = document.createElement("div");
          sectionBlock.className = "stats-section";
          const heading = document.createElement("h3");
          heading.textContent = section[currentLanguage].title;
          sectionBlock.appendChild(heading);

          sectionQuestions.forEach((question) => {
            const counts = cloudTotals[question.id] || {};
            const total = Object.values(counts).reduce((sum, value) => sum + value, 0);

            const card = document.createElement("article");
            card.className = "stats-card";

            const title = document.createElement("h3");
            title.textContent = question.text?.[currentLanguage] || "";
            card.appendChild(title);

            const totalText = document.createElement("p");
            totalText.className = "stats-total";
            totalText.textContent = meta.responsesLabel(total);
            card.appendChild(totalText);

            if (!question.options || !question.options.length || question.type === "text") {
              const note = document.createElement("p");
              note.className = "stats-text-note";
              note.textContent = meta.textQuestionNote(total);
              card.appendChild(note);
            } else {
              question.options.forEach((option) => {
                const optionWrap = document.createElement("div");
                optionWrap.className = "stats-option";

                const head = document.createElement("div");
                head.className = "option-head";

                const label = document.createElement("strong");
                label.textContent = option.label?.[currentLanguage] || "";

                const detail = document.createElement("span");
                const count = counts[option.value] || 0;
                const percent = total ? Math.round((count / total) * 100) : 0;
                detail.textContent = `${count} Â· ${percent}%`;

                head.appendChild(label);
                head.appendChild(detail);

                const progress = document.createElement("div");
                progress.className = "progress";
                const bar = document.createElement("span");
                bar.style.width = `${percent}%`;
                progress.appendChild(bar);

                optionWrap.appendChild(head);
                optionWrap.appendChild(progress);
                card.appendChild(optionWrap);
              });
            }

            sectionBlock.appendChild(card);
          });

          ui.statsContent.appendChild(sectionBlock);
        });
      };

      const renderResponseFeedList = () => {
        if (!ui.responsesFeed || !ui.responsesEmpty) return;
        const meta = uiMeta[currentLanguage];
        ui.responsesFeed.innerHTML = "";
        if (responseFeedLoading) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesLoading;
          return;
        }
        if (responseFeedError) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesError;
          return;
        }
        if (!responseFeedItems.length) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesEmpty;
          return;
        }
        ui.responsesEmpty.hidden = true;
        responseFeedItems.forEach((record) => {
          const entry = document.createElement("article");
          entry.className = "response-entry";

          const time = document.createElement("time");
          time.dateTime = record.submitted_at;
          time.textContent = formatTimestamp(record.submitted_at);
          entry.appendChild(time);

          const answers = record.answers && typeof record.answers === "object" ? record.answers : {};
          Object.entries(answers).forEach(([questionId, value]) => {
            const question = findQuestionById(questionId);
            if (!question) return;
            const description = describeAnswer(question, value);
            if (!description) return;

            const answerLine = document.createElement("p");
            answerLine.className = "response-answer";

            const strong = document.createElement("strong");
            strong.textContent = question.text?.[currentLanguage] || question.text?.zh || questionId;
            answerLine.appendChild(strong);
            answerLine.appendChild(document.createElement("br"));
            answerLine.appendChild(document.createTextNode(description));

            entry.appendChild(answerLine);
          });

          ui.responsesFeed.appendChild(entry);
        });
      };

      const fetchResponseFeed = async () => {
        const params = new URLSearchParams({
          select: "answers,submitted_at",
          order: "submitted_at.desc",
          limit: RESPONSE_FETCH_LIMIT
        });
        const requestUrl = `${SUPABASE_RESPONSES_ENDPOINT}?${params.toString()}`;
        const response = await fetch(requestUrl, { headers: supabaseHeaders });
        if (!response.ok) {
          throw new Error(`Failed to load response feed: ${response.status}`);
        }
        return response.json();
      };

      const loadResponseFeed = async () => {
        if (responseFeedLoading) return;
        responseFeedLoading = true;
        responseFeedError = null;
        renderResponseFeedList();
        try {
          const records = await fetchResponseFeed();
          responseFeedItems = Array.isArray(records)
            ? records.map((item) => ({
                submitted_at: item.submitted_at,
                answers: item.answers
              }))
            : [];
        } catch (error) {
          responseFeedError = error;
        } finally {
          responseFeedLoading = false;
          renderResponseFeedList();
        }
      };

      const switchScreen = (target) => {
        if (!ui.builderView || !ui.statsView) return;
        if (target === currentScreen) {
          if (target === "stats") {
            renderStats();
            loadCloudStats();
            loadResponseFeed();
          }
          return;
        }
        currentScreen = target;
        const showBuilder = target === "builder";
        ui.builderView.hidden = !showBuilder;
        ui.statsView.hidden = showBuilder;
        if (ui.builderTab) {
          ui.builderTab.classList.toggle("active", showBuilder);
        }
        if (ui.statsTab) {
          ui.statsTab.classList.toggle("active", !showBuilder);
        }
        if (!showBuilder) {
          renderStats();
          loadCloudStats();
          loadResponseFeed();
        }
      };

      const renderCopyEditor = () => {
        const meta = uiMeta[currentLanguage];
        const copy = contentText[currentLanguage];
        copyEditor.innerHTML = "";

        const head = document.createElement("div");
        head.className = "copy-head";
        const eyebrow = document.createElement("p");
        eyebrow.className = "eyebrow";
        eyebrow.textContent = meta.copyLabel;
        const heading = document.createElement("h3");
        heading.textContent = meta.copyTitle;
        head.appendChild(eyebrow);
        head.appendChild(heading);
        copyEditor.appendChild(head);

        const helper = document.createElement("p");
        helper.className = "copy-helper";
        helper.textContent = meta.copyHelper;
        copyEditor.appendChild(helper);

        const grid = document.createElement("div");
        grid.className = "copy-grid";

        copyFieldConfig.forEach((field) => {
          const wrapper = document.createElement("label");
          wrapper.className = "copy-field";

          const span = document.createElement("span");
          span.textContent = meta.copyFieldLabels[field.id];

          const control =
            field.type === "textarea" ? document.createElement("textarea") : document.createElement("input");
          if (field.type !== "textarea") {
            control.type = "text";
          }
          control.value = copy[field.id] || "";
          control.addEventListener("input", (event) => {
            contentText[currentLanguage][field.id] = event.target.value;
            updateUIText();
          });

          wrapper.appendChild(span);
          wrapper.appendChild(control);
          grid.appendChild(wrapper);
        });

        copyEditor.appendChild(grid);
      };

      const handleSubmit = async () => {
        if (!questionList) return;
        if (!questionList.reportValidity()) {
          return;
        }

        const meta = uiMeta[currentLanguage];
        const formData = new FormData(questionList);
        const submissionPayload = {};
        let hasMissing = false;
        let firstInvalidQuestion = null;

        const markMissing = (question) => {
          if (!hasMissing) {
            firstInvalidQuestion = question.id;
          }
          hasMissing = true;
        };

        questions.forEach((question) => {
          if (question.type === "single") {
            const selectedValue = formData.get(question.id);
            if (!selectedValue) {
              markMissing(question);
              return;
            }
            const option = findOptionByValue(question, selectedValue.toString());
            if (!option) {
              markMissing(question);
              return;
            }
            const entry = { type: "single", selection: selectedValue.toString() };
            if (option.hasTextInput) {
              const extraValue = (formData.get(`${question.id}__${option.value}__text`) || "").toString().trim();
              if (!extraValue) {
                markMissing(question);
                return;
              }
              entry.otherText = extraValue;
            }
            submissionPayload[question.id] = entry;
          } else if (question.type === "multi") {
            const selections = formData.getAll(question.id).map((value) => value.toString());
            if (!selections.length) {
              markMissing(question);
              return;
            }
            const entry = { type: "multi", selections };
            const otherText = {};
            selections.forEach((selected) => {
              const option = findOptionByValue(question, selected);
              if (option?.hasTextInput) {
                const extraValue = (formData.get(`${question.id}__${option.value}__text`) || "").toString().trim();
                if (!extraValue) {
                  markMissing(question);
                } else {
                  otherText[selected] = extraValue;
                }
              }
            });
            if (hasMissing) {
              return;
            }
            if (Object.keys(otherText).length) {
              entry.otherText = otherText;
            }
            submissionPayload[question.id] = entry;
          } else if (question.type === "text") {
            const textValue = (formData.get(question.id) || "").toString().trim();
            if (!textValue) {
              markMissing(question);
              return;
            }
            submissionPayload[question.id] = { type: "text", text: textValue };
          }
        });

        if (hasMissing) {
          if (firstInvalidQuestion) {
            const target = questionList.querySelector(`[data-question-id="${firstInvalidQuestion}"]`);
            target?.scrollIntoView({ behavior: "smooth", block: "center" });
          }
          alert(meta.requiredError);
          return;
        }

        questionList.reset();
        renderPreview();
        alert(meta.submitSuccess);
        switchScreen("stats");
        saveResponseSubmission(submissionPayload).then(() => {
          loadCloudStats();
          loadResponseFeed();
        });
      };

      const updateUIText = () => {
        const copy = contentText[currentLanguage];
        const meta = uiMeta[currentLanguage];
        setText(ui.heroEyebrow, copy.heroEyebrow);
        setText(ui.heroTitle, copy.heroTitle);
        setText(ui.heroDesc, copy.heroDesc);
        setText(ui.previewLabel, copy.previewLabel);
        setText(ui.previewTitle, copy.previewTitle);
        setText(ui.editorLabel, copy.editorLabel);
        setText(ui.editorTitle, copy.editorTitle);
        setText(ui.scrollDownLabel, copy.scrollDown);
        setText(ui.addQuestion, copy.addQuestion);
        setText(ui.submit, copy.submit);
        setText(ui.langToggle, meta.toggle);
        setText(ui.logoLabel, meta.logoLabel);
        setText(ui.logoTitle, meta.logoTitle);
        setText(ui.logoHelper, meta.logoHelper);
        setText(ui.logoUploadText, meta.logoUpload);
        setText(ui.logoResetButton, meta.logoReset);
        setText(ui.qrLabel, meta.qrLabel);
        setText(ui.qrTitle, meta.qrTitle);
        setText(ui.qrHelper, meta.qrHelper);
        setText(ui.qrInputLabel, meta.qrInputLabel);
        setText(ui.qrRefresh, meta.qrRefresh);
        setText(ui.qrNote, meta.qrNote);
        setText(ui.adminButton, meta.adminButton);
        setText(ui.exitAdminButton, meta.exitAdminButton || "");
        setText(ui.saveButton, meta.saveChanges || "");
        setText(ui.builderTab, meta.tabBuilder);
        setText(ui.statsTab, meta.tabStats);
        setText(ui.statsLabel, meta.statsLabel);
        setText(ui.statsTitle, meta.statsTitle);
        setText(ui.statsHelper, meta.statsHelper);
        setText(ui.statsEmpty, meta.statsEmpty);
        setText(ui.responsesLabel, meta.responsesPanelLabel);
        setText(ui.responsesTitle, meta.responsesPanelTitle);
        setText(ui.responsesHelper, meta.responsesHelper);
        setText(ui.responseRefresh, meta.responsesRefresh);
        if (!responseFeedItems.length && !responseFeedLoading) {
          setText(ui.responsesEmpty, meta.responsesEmpty);
        }
        renderStats();
        renderResponseFeedList();
      };

      const loadCloudStats = async () => {
        statsLoading = true;
        statsError = null;
        renderStats();
        try {
          const params = new URLSearchParams({
            select: "answers,submitted_at",
            order: "submitted_at.desc",
            limit: STATS_FETCH_LIMIT.toString()
          });
          const response = await fetch(`${SUPABASE_RESPONSES_ENDPOINT}?${params.toString()}`, {
            headers: supabaseHeaders
          });
          if (!response.ok) {
            throw new Error(`Failed to load cloud stats (${response.status})`);
          }
          const data = await response.json();
          const records = Array.isArray(data) ? data : [];
          cloudTotals = aggregateCloudTotals(records);
          cloudSubmissionCount = records.length;
          cloudLastUpdated = records[0]?.submitted_at || null;
        } catch (error) {
          statsError = error;
        } finally {
          statsLoading = false;
          renderStats();
        }
      };

      if (ui.addQuestion) {
        ui.addQuestion.addEventListener("click", () => {
          const count = questions.length + 1;
          const newId = createId();
          const newQuestion = {
            id: newId,
            sectionId: questionSections[0].id,
            type: "single",
            required: true,
            text: {
              zh: `æ–°é—®é¢˜ ${count}`,
              en: `New question ${count}`
            },
            description: {
              zh: "",
              en: ""
            },
            options: [
              { value: "option-a", label: { zh: "é€‰é¡¹ 1", en: "Option 1" } },
              { value: "option-b", label: { zh: "é€‰é¡¹ 2", en: "Option 2" } },
              { value: "option-c", label: { zh: "é€‰é¡¹ 3", en: "Option 3" } }
            ]
          };
          questions.push(newQuestion);
          renderEditor();
          renderPreview();
          renderStats();
        });
      }

      ui.langToggle.addEventListener("click", () => {
        currentLanguage = currentLanguage === "zh" ? "en" : "zh";
        document.documentElement.lang = currentLanguage === "zh" ? "zh-CN" : "en";
        renderCopyEditor();
        renderEditor();
        renderPreview();
        updateUIText();
      });

      if (ui.builderTab) {
        ui.builderTab.addEventListener("click", () => switchScreen("builder"));
      }

      if (ui.statsTab) {
        ui.statsTab.addEventListener("click", () => switchScreen("stats"));
      }

      if (ui.responseRefresh) {
        ui.responseRefresh.addEventListener("click", () => {
          loadResponseFeed();
        });
      }

      if (ui.submit) {
        ui.submit.addEventListener("click", handleSubmit);
      }

      if (ui.adminButton) {
        ui.adminButton.addEventListener("click", () => {
          const meta = uiMeta[currentLanguage];
          const input = window.prompt(meta.adminPrompt);
          if (input === null) return;
          if (input.trim() === ADMIN_PASSWORD) {
            enableAdminMode();
          } else {
            alert(meta.adminError);
          }
        });
      }

      if (ui.exitAdminButton) {
        ui.exitAdminButton.addEventListener("click", () => {
          disableAdminMode();
        });
      }

      if (ui.saveButton) {
        ui.saveButton.addEventListener("click", async () => {
          const meta = uiMeta[currentLanguage];
          persistQuestions();
          persistContent();
          ui.saveButton.disabled = true;
          try {
            await saveRemoteConfig({ questions, contentText, logoDataUrl: currentLogoDataUrl });
            alert(meta.saveSuccess || "å·²ä¿å­˜");
          } catch (error) {
            alert(currentLanguage === "zh" ? "ä¿å­˜å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚" : "Failed to save. Please try again.");
          } finally {
            ui.saveButton.disabled = false;
          }
        });
      }

      if (ui.qrRefresh) {
        ui.qrRefresh.addEventListener("click", updateQrFromInput);
      }

      if (ui.qrUrlInput) {
        ui.qrUrlInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            updateQrFromInput();
          }
        });
      }

      if (ui.logoInput) {
        ui.logoInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          if (file.size > LOGO_MAX_BYTES) {
            alert(currentLanguage === "zh" ? "è¯·é€‰æ‹© 2 MB ä»¥ä¸‹çš„å›¾ç‰‡æ–‡ä»¶ã€‚" : "Please choose an image smaller than 2 MB.");
            event.target.value = "";
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = reader.result;
            if (typeof dataUrl === "string") {
              currentLogoDataUrl = dataUrl;
              applyLogoSrc(dataUrl);
              persistLogo(dataUrl);
            }
          };
          reader.onerror = () => {
            alert(currentLanguage === "zh" ? "æ— æ³•è¯»å–æ–‡ä»¶ï¼Œè¯·é‡è¯•ã€‚" : "Unable to read the file. Please try again.");
          };
          reader.readAsDataURL(file);
        });
      }

      if (ui.logoResetButton) {
        ui.logoResetButton.addEventListener("click", () => {
          persistLogo(null);
          currentLogoDataUrl = null;
          applyLogoSrc(DEFAULT_LOGO_SRC);
          if (ui.logoInput) {
            ui.logoInput.value = "";
          }
        });
      }

      if (ui.scrollRange && editorList) {
        ui.scrollRange.addEventListener("input", (event) => {
          const maxScroll = editorList.scrollHeight - editorList.clientHeight;
          if (maxScroll <= 0) return;
          const ratio = Number(event.target.value) / 100;
          editorList.scrollTop = ratio * maxScroll;
        });
      }

      if (editorList) {
        editorList.addEventListener("scroll", syncScrollHandle);
        window.addEventListener("resize", syncScrollHandle);
      }

      const bootstrap = async () => {
        let syncedLogo = false;
        try {
          const remoteConfig = await fetchRemoteConfig();
          if (remoteConfig) {
            if (isValidQuestionSet(remoteConfig.questions)) {
              questions = remoteConfig.questions;
              persistQuestions();
            }
            if (remoteConfig.contentText) {
              contentText = remoteConfig.contentText;
              persistContent();
            }
            if (remoteConfig.logoDataUrl) {
              currentLogoDataUrl = remoteConfig.logoDataUrl;
              applyLogoSrc(currentLogoDataUrl);
              persistLogo(currentLogoDataUrl);
              syncedLogo = true;
            }
          }
        } catch (error) {
          console.warn("Unable to load remote config, falling back to local cache");
        }

        if (!syncedLogo) {
          loadStoredLogo();
        }

        initQrSection();

        const searchParams = new URLSearchParams(window.location.search);
        if (searchParams.get("admin") === "1" || sessionStorage.getItem(ADMIN_MODE_KEY) === "true") {
          enableAdminMode();
        } else {
          disableAdminMode();
        }

        renderPreview();
        renderEditor();
        renderCopyEditor();
        renderStats();
        loadCloudStats();
        loadResponseFeed();
        updateUIText();
      };

      bootstrap();
    </script>
  </body>
</html>
