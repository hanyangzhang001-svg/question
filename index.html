<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Survey Builder</title>
    <link rel="icon" type="image/svg+xml" href="./assets/logo.svg" />
    <script src="./config.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg: #edf2fb;
        --surface: #ffffff;
        --accent: #6c7ae0;
        --accent-strong: #5661c5;
        --text: #1f2a44;
        --muted: #7c88b0;
        --border: rgba(31, 42, 68, 0.12);
        --soft: rgba(108, 122, 224, 0.08);
        font-family: "Inter", "PingFang SC", "Microsoft YaHei", system-ui,
          -apple-system, BlinkMacSystemFont, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #fdf2ff 0%, #edf4ff 40%, var(--bg) 100%);
        padding: 48px 24px 64px;
        color: var(--text);
      }

      .page {
        max-width: 1180px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 32px;
      }

      .qr-card {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(220px, 0.8fr);
        gap: 32px;
        background: var(--surface);
        border-radius: 28px;
        padding: 32px 40px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.08);
        align-items: center;
      }

      .qr-content h2 {
        margin: 8px 0 12px;
      }

      .qr-helper {
        margin: 0 0 18px;
        color: var(--muted);
        line-height: 1.6;
      }

      .qr-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .qr-form label {
        font-size: 0.9rem;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .qr-form input {
        border-radius: 14px;
        border: 1px solid var(--border);
        padding: 12px 14px;
        font-size: 0.95rem;
      }

      .qr-form input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--soft);
      }

      .qr-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .qr-preview {
        border-radius: 24px;
        border: 1px dashed rgba(108, 122, 224, 0.25);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        justify-content: center;
        background: rgba(247, 249, 255, 0.9);
      }

      .qr-canvas {
        width: 180px;
        height: 180px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .qr-canvas img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .qr-note {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
        text-align: center;
      }

      .page-tabs {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 20px;
        padding: 6px;
        border: 1px solid var(--border);
      }

      .tab-btn {
        flex: 1;
        border: none;
        background: transparent;
        color: var(--muted);
        font-weight: 600;
        padding: 12px 20px;
        border-radius: 16px;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .tab-btn.active {
        background: var(--text);
        color: white;
      }

      .hero {
        display: flex;
        justify-content: space-between;
        gap: 24px;
        align-items: center;
        background: var(--surface);
        border-radius: 28px;
        padding: 32px 40px;
        box-shadow: 0 25px 60px rgba(31, 42, 68, 0.12);
        border: 1px solid var(--border);
      }

      .hero-actions {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: flex-end;
      }

      .hero-brand {
        display: flex;
        align-items: center;
        gap: 24px;
        flex: 1;
      }

      .hero-logo {
        width: 110px;
        max-height: 110px;
        object-fit: contain;
      }

      .hero-copy {
        flex: 1;
      }

      .hero h1 {
        margin: 6px 0 12px;
        font-size: 2rem;
        letter-spacing: -0.02em;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        max-width: 560px;
        line-height: 1.6;
      }

      .eyebrow {
        font-size: 0.85rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--accent-strong);
      }

      .toggle {
        background: rgba(108, 122, 224, 0.1);
        color: var(--accent-strong);
        border: none;
        padding: 12px 20px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
        white-space: nowrap;
      }

      .toggle:hover {
        transform: translateY(-1px);
        background: rgba(108, 122, 224, 0.16);
      }

      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 24px;
      }

      .admin-mode .layout {
        grid-template-columns: minmax(0, 1.1fr) minmax(320px, 0.9fr);
      }

      .panel {
        background: var(--surface);
        border-radius: 28px;
        padding: 32px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.08);
        display: flex;
        flex-direction: column;
        gap: 24px;
        overflow: visible;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: center;
      }

      .panel-actions {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .panel h2 {
        margin: 6px 0 0;
      }

      .ghost {
        background: transparent;
        border: 1px dashed var(--accent);
        color: var(--accent-strong);
        padding: 10px 18px;
        border-radius: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: border 0.2s ease, color 0.2s ease;
      }

      .ghost:hover {
        border-color: var(--accent-strong);
        color: var(--accent-strong);
      }

      .ghost-small {
        padding: 8px 14px;
        border-radius: 12px;
      }

      .scroll-control {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 220px;
      }

      .editor-controls {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .scroll-label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .scroll-range {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--accent) 0%, rgba(108, 122, 224, 0.35) 100%);
        position: relative;
        cursor: pointer;
      }

      .scroll-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--surface);
        border: 2px solid var(--accent);
        box-shadow: 0 4px 15px rgba(31, 42, 68, 0.2);
      }

      .scroll-range::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--surface);
        border: 2px solid var(--accent);
        box-shadow: 0 4px 15px rgba(31, 42, 68, 0.2);
      }

      .scroll-range:disabled {
        cursor: not-allowed;
        opacity: 0.35;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .question {
        padding: 24px 24px 22px;
        border-radius: 22px;
        border: 1px solid rgba(108, 122, 224, 0.15);
        background: linear-gradient(135deg, rgba(108, 122, 224, 0.04), rgba(255, 255, 255, 0.9));
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .question-section {
        margin-bottom: 32px;
      }

      .question-section h3 {
        margin-bottom: 12px;
        font-size: 1.05rem;
        color: var(--accent-strong);
      }

      .question-head {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .question-required {
        font-size: 0.75rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--accent-strong);
      }

      .question-description {
        margin: -8px 0 8px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .survey-intro {
        padding: 20px 24px;
        border-radius: 22px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px dashed rgba(108, 122, 224, 0.35);
        margin-bottom: 12px;
      }

      .survey-intro h2 {
        margin: 0 0 8px;
        font-size: 1.2rem;
      }

      .survey-intro p {
        margin: 6px 0;
        color: var(--muted);
        line-height: 1.6;
      }

      .question-title {
        font-size: 1.05rem;
        margin: 0 0 16px;
        font-weight: 600;
      }

      .options {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .option {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid transparent;
        cursor: pointer;
        transition: border 0.2s ease, transform 0.2s ease;
      }

      .option:hover {
        border-color: rgba(108, 122, 224, 0.4);
        transform: translateY(-1px);
      }

      .option input {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid var(--muted);
        display: grid;
        place-items: center;
        margin: 0;
      }

      .option input::after {
        content: "";
        width: 8px;
        height: 8px;
        background: var(--accent);
        border-radius: 50%;
        transform: scale(0);
        transition: transform 0.15s ease;
      }

      .option input:checked {
        border-color: var(--accent);
      }

      .option input:checked::after {
        transform: scale(1);
      }

      .option input[type="checkbox"] {
        border-radius: 6px;
      }

      .option input[type="checkbox"]::after {
        border-radius: 2px;
      }

      .badge {
        width: 32px;
        height: 32px;
        border-radius: 16px;
        background: rgba(108, 122, 224, 0.15);
        color: var(--accent-strong);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
      }

      .option-text {
        font-size: 0.95rem;
      }

      .option-extra {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 0.9rem;
        margin-top: 6px;
      }

      .submit {
        border: none;
        border-radius: 18px;
        padding: 16px;
        background: linear-gradient(120deg, #6c7ae0, #8da2fb);
        color: white;
        font-size: 1rem;
        letter-spacing: 0.04em;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 18px 35px rgba(108, 122, 224, 0.3);
      }

      .editor-panel {
        gap: 20px;
        display: none;
      }

      .admin-mode .editor-panel {
        display: flex;
      }

      .logo-uploader {
        border: 1px dashed var(--border);
        border-radius: 20px;
        padding: 20px 22px;
        background: rgba(247, 249, 255, 0.84);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .logo-head {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }

      .logo-copy h3 {
        margin: 0;
        font-size: 1rem;
      }

      .logo-helper {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .logo-actions {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }

      .upload-btn {
        border-radius: 14px;
        padding: 10px 18px;
        background: rgba(108, 122, 224, 0.12);
        color: var(--accent-strong);
        font-weight: 600;
        cursor: pointer;
        border: 1px solid transparent;
        transition: transform 0.2s ease, border 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .upload-btn:hover {
        transform: translateY(-1px);
        border-color: rgba(108, 122, 224, 0.5);
      }

      .copy-editor {
        border: 1px dashed var(--border);
        border-radius: 20px;
        padding: 20px 22px;
        background: rgba(247, 249, 255, 0.84);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .copy-head h3 {
        margin: 0;
        font-size: 1rem;
      }

      .copy-helper {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .copy-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px 16px;
      }

      .copy-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.9rem;
      }

      .copy-field textarea {
        min-height: 72px;
        resize: vertical;
      }

      .stats-panel {
        background: var(--surface);
        border-radius: 28px;
        padding: 32px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 50px rgba(31, 42, 68, 0.06);
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .stats-helper {
        margin: 0;
        color: var(--muted);
      }

      .stats-list {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .stats-card {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 22px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .stats-card h3 {
        margin: 0;
        font-size: 1rem;
      }

      .stats-total {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .stats-option {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 10px 0;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
      }

      .stats-option:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      .stats-section {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .stats-section + .stats-section {
        margin-top: 28px;
      }

      .stats-section h3 {
        margin: 0;
        font-size: 1rem;
        color: var(--accent-strong);
      }

      .stats-text-note {
        margin: 4px 0 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .response-panel {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 22px;
        padding: 24px;
        background: rgba(247, 249, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .response-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .response-helper {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .response-feed {
        display: flex;
        flex-direction: column;
        gap: 14px;
        max-height: 360px;
        overflow-y: auto;
      }

      .response-entry {
        border: 1px solid rgba(108, 122, 224, 0.18);
        border-radius: 18px;
        padding: 14px 16px;
        background: white;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .response-entry time {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .response-answer {
        margin: 0;
        font-size: 0.92rem;
        line-height: 1.55;
      }

      .response-empty {
        margin: 0;
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .option-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.92rem;
      }

      .option-head strong {
        color: var(--accent-strong);
        letter-spacing: 0.08em;
      }

      .progress {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.08);
        overflow: hidden;
      }

      .progress span {
        display: block;
        height: 100%;
        background: linear-gradient(90deg, #6c7ae0, #8da2fb);
      }

      .stats-empty {
        margin: 0;
        padding: 24px;
        text-align: center;
        border-radius: 18px;
        border: 1px dashed var(--border);
        color: var(--muted);
        background: rgba(247, 249, 255, 0.8);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }

      .editor-divider {
        height: 1px;
        width: 100%;
        background: linear-gradient(
          90deg,
          rgba(108, 122, 224, 0),
          rgba(108, 122, 224, 0.35),
          rgba(108, 122, 224, 0)
        );
      }

      .editor-list {
        display: flex;
        flex-direction: column;
        gap: 18px;
        overflow-y: auto;
        padding-right: 4px;
        scroll-behavior: smooth;
        max-height: clamp(280px, 48vh, 520px);
        min-height: 240px;
        border-radius: 16px;
        padding-bottom: 4px;
      }

      .editor-card {
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 20px;
        background: rgba(247, 249, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .editor-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .editor-card header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .remove {
        border: none;
        background: rgba(255, 67, 86, 0.12);
        color: #d8344e;
        border-radius: 12px;
        padding: 6px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      label span {
        font-size: 0.85rem;
        color: var(--muted);
        display: inline-block;
        margin-bottom: 6px;
      }

      textarea,
      input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: white;
        font-size: 0.95rem;
        resize: vertical;
        min-height: 42px;
      }

      textarea {
        min-height: 64px;
      }

      textarea:focus,
      input[type="text"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--soft);
      }

      @media (max-width: 1024px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .editor-panel {
          max-height: none;
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 32px 16px 48px;
        }

        .hero {
          flex-direction: column;
        }

        .hero-brand {
          flex-direction: column;
          align-items: flex-start;
        }

        .hero-actions {
          width: 100%;
          align-items: flex-start;
        }

        .panel {
          padding: 24px;
        }

        .qr-card {
          grid-template-columns: 1fr;
          padding: 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header class="hero">
        <div class="hero-brand">
          <img src="./assets/logo.svg" alt="After Wags logo" class="hero-logo" />
          <div class="hero-copy">
            <p class="eyebrow" id="hero-eyebrow">Live Survey Builder</p>
            <h1 id="hero-title">Pet Toy Sustainability Survey</h1>
            <p id="hero-desc">
              Preview every tweak instantly, share QR links, and collaborate in two languages with a modern, minimal layout.
            </p>
          </div>
        </div>
        <div class="hero-actions">
          <button id="lang-toggle" class="toggle" type="button">切换到 English</button>
          <button id="admin-button" class="ghost" type="button">管理员入口</button>
          <button id="exit-admin-button" class="ghost" type="button" hidden>退出管理员模式</button>
        </div>
      </header>

      <section class="qr-card">
        <div class="qr-content">
          <p class="eyebrow" id="qr-label">Scan to open</p>
          <h2 id="qr-title">QR entry point</h2>
          <p class="qr-helper" id="qr-helper">
            Share the survey link to any channel and let people scan to open it instantly. Customize the URL to match your deployment.
          </p>
          <div class="qr-form">
            <label>
              <span id="qr-input-label">Destination URL</span>
              <input id="qr-url" type="url" placeholder="https://example.com/survey" />
            </label>
            <div class="qr-actions">
              <button id="qr-refresh" class="ghost" type="button">Update QR code</button>
            </div>
          </div>
        </div>
        <div class="qr-preview">
          <div id="qr-code" class="qr-canvas" aria-label="二维码"></div>
          <p class="qr-note" id="qr-note">Scan on mobile to open the survey</p>
        </div>
      </section>

      <nav class="page-tabs">
        <button id="tab-builder" class="tab-btn active" type="button">Survey builder</button>
        <button id="tab-stats" class="tab-btn" type="button">Response stats</button>
      </nav>

      <section id="builder-view" class="layout builder-view">
        <div class="panel preview-panel">
          <div class="panel-header">
            <div>
              <p class="eyebrow" id="preview-label">Preview</p>
              <h2 id="preview-title">What participants will see</h2>
            </div>
          </div>

          <form id="question-list" novalidate></form>
          <button id="submit-btn" class="submit" type="button">Submit survey</button>
        </div>

        <div class="panel editor-panel" hidden aria-hidden="true">
          <div class="panel-header">
            <div>
              <p class="eyebrow" id="editor-label">Editor</p>
              <h2 id="editor-title">Update questions & options</h2>
            </div>
            <div class="panel-actions">
              <button id="save-editor" class="toggle" type="button">Save changes</button>
            </div>
          </div>

          <div class="logo-uploader">
            <div class="logo-head">
              <div class="logo-copy">
                <p class="eyebrow" id="logo-label">Brand logo</p>
                <h3 id="logo-title">Upload your own mark</h3>
                <p class="logo-helper" id="logo-helper">
                  Supports PNG / JPG / SVG (≤2MB). Transparent backgrounds work best.
                </p>
              </div>
              <div class="logo-actions">
                <label class="upload-btn">
                  <input id="logo-input" type="file" accept="image/*" hidden />
                  <span id="logo-upload-text">Upload image</span>
                </label>
                <button id="logo-reset" class="ghost-small" type="button">Reset</button>
              </div>
            </div>
          </div>

          <div id="copy-editor" class="copy-editor"></div>

          <div class="editor-divider"></div>
          <div class="editor-controls">
            <div class="scroll-control">
              <span class="scroll-label" id="scroll-editor-label">Drag to scroll questions</span>
              <input
                id="scroll-editor-range"
                class="scroll-range"
                type="range"
                min="0"
                max="100"
                value="0"
              />
            </div>
            <button id="add-question" class="ghost" type="button">Add question</button>
          </div>
          <div id="editor-list" class="editor-list"></div>
        </div>
      </section>

      <section id="stats-view" class="stats-panel" hidden>
        <div class="panel-header">
          <div>
            <p class="eyebrow" id="stats-label">Response stats</p>
            <h2 id="stats-title">Overall answer overview</h2>
          </div>
        </div>
        <p class="stats-helper" id="stats-helper">Track the preference for each option and monitor trends in real time.</p>
        <div id="stats-content" class="stats-list"></div>
        <p id="stats-empty" class="stats-empty" hidden>No submissions yet.</p>
        <div class="response-panel">
          <div class="response-head">
            <div>
              <p class="eyebrow" id="responses-label">Response log</p>
              <h3 id="responses-title">Latest submissions</h3>
            </div>
            <button id="response-refresh" class="ghost-small" type="button">Refresh list</button>
          </div>
          <p class="response-helper" id="responses-helper">
            Pulls the 50 most recent responses from Supabase so you can review open text answers and choices.
          </p>
          <div id="response-feed" class="response-feed"></div>
          <p id="response-empty" class="response-empty">No submissions have been synced yet.</p>
        </div>
      </section>

    </div>

    <script>

      const surveyIntro = {
        zh: {
          title: "多玩少买：狗狗与猫咪主人的问卷",
          description: [
            "感谢你抽空参与本问卷。我们是纽约视觉艺术学院（SVA）社会创新设计硕士项目的学生研究团队，目前正在研究宠物玩具的过度消费，并寻找让宠物和主人更可持续、也更有趣地共度时光的方式。",
            "本问卷大约 5 分钟，面向会为宠物购买玩具的猫狗主人。我们想了解你购买、使用与处理宠物玩具的方式，你对环保材料的看法，以及你对 DIY 玩具的兴趣。这些回答有助于我们理解现实生活中 DIY 的困难，并思考如何把“买了就闲置”的玩具，变成“自己做、循环用、玩得更久”。",
            "填答完全自愿，你可以跳过任何不想回答的问题。所有结果只用于学术研究与设计，不会以可识别个人的方式对外分享。"
          ]
        },
        en: {
          title: "Play More, Buy Less: A Survey for Dog and Cat Owners",
          description: [
            "Thank you for taking the time to visit this survey. We are a student research team from the MFA Design for Social Innovation program at the School of Visual Arts (SVA) in New York. Our current project looks at pet toy overconsumption and explores more sustainable, playful ways for pets and owners to spend time together.",
            "This anonymous survey (about 5 minutes) is for dog and cat owners who buy toys for their pets. We would like to learn how you purchase, use, and handle pet toys, your views on eco-friendly materials, and your interest in DIY pet toys. Your answers will help us understand what makes DIY difficult in real life, and how we might turn “buy then idle” toys into “make, reuse, and play longer.”",
            "Participation is completely voluntary. You may skip any question you do not wish to answer. All responses will be used only for academic research and design purposes and will not be shared in a way that can identify you."
          ]
        }
      };


      const questionSections = [
        {
          id: "purchase",
          zh: { title: "第一部分：宠物玩具购买行为与动机", summary: "了解你买玩具的频率、预算与动机。" },
          en: { title: "Section 1. Pet Toy Purchasing Behavior & Motivation", summary: "Frequency, spend, and purchase drivers." }
        },
        {
          id: "usage",
          zh: { title: "第二部分：玩具使用与处理方式", summary: "使用时长、损坏情况、闲置处理与 DIY 意愿。" },
          en: { title: "Section 2. Toy Usage & Disposal Patterns", summary: "Usage, damage, idle handling, and DIY interest." }
        },
        {
          id: "sustainability",
          zh: { title: "第三部分：对可持续宠物用品的认知与态度", summary: "了解环保材料的重要性与溢价接受度。" },
          en: { title: "Section 3. Awareness & Attitudes Toward Sustainable Pet Products", summary: "Awareness, importance, and price sensitivity." }
        },
        {
          id: "reuse",
          zh: { title: "第四部分：对玩具再利用、回收与捐赠的态度", summary: "参与意愿、影响因素与再设计兴趣。" },
          en: { title: "Section 4. Attitudes Toward Toy Reuse / Recycling / Donation", summary: "Participation, factors, and redesign interest." }
        },
        {
          id: "basic",
          zh: { title: "第五部分：更多背景信息", summary: "宠物类型、年龄范围与职业等。" },
          en: { title: "Section 5. More information", summary: "Pet types, age range, and occupation." }
        },
        {
          id: "open",
          zh: { title: "第六部分：开放式问题", summary: "填写你对宠物玩具的更多想法，可选留下邮箱。" },
          en: { title: "Section 6. Open-Ended Questions", summary: "Short answers and optional interview email." }
        }
      ];

      const uiMeta = {
        zh: {
          toggle: "切换到 English",
          remove: "删除",
          questionTitle: (index) => `问题 ${index}`,
          questionPlaceholder: "请输入题目内容",
          notePlaceholder: "（可选）补充说明",
          optionPlaceholder: (index) => `选项 ${index}`,
          adminButton: "管理员入口",
          exitAdminButton: "退出管理员模式",
          adminPrompt: "请输入管理员密码",
          adminError: "密码错误，请重试",
          tabBuilder: "问卷设计",
          tabStats: "回答统计",
          statsLabel: "回答统计",
          statsTitle: "整体回答概览",
          statsHelper: "查看每个选项被选择的次数，追踪不同题目的回答趋势。",
          statsEmpty: "还没有任何提交记录。",
          submitSuccess: "提交成功，感谢反馈！",
          responsesLabel: (count) => `共 ${count} 份回答`,
          responsesPanelLabel: "回答记录",
          responsesPanelTitle: "最新提交",
          responsesHelper: "自动从 Supabase 获取最近 50 条回答，方便查看开放题文本与具体选择。",
          responsesEmpty: "暂时没有回答记录。",
          responsesRefresh: "刷新列表",
          responsesLoading: "正在加载最新的回答记录…",
          responsesError: "暂时无法获取回答，请稍后再试。",
          qrLabel: "扫码直达",
          qrTitle: "二维码入口",
          qrHelper: "将问卷链接分享到任何渠道，扫码即可直接打开当前页面。可自定义网址来匹配部署地址。",
          qrInputLabel: "跳转链接",
          qrRefresh: "更新二维码",
          qrNote: "手机扫码立即打开问卷",
          qrInvalid: "请输入有效的 http(s) 链接。",
          logoLabel: "品牌 Logo",
          logoTitle: "上传自定义图像",
          logoHelper: "支持 PNG / JPG / SVG（≤2MB），建议透明背景。",
          logoUpload: "上传图片",
          logoReset: "恢复默认",
          copyLabel: "页面文案",
          copyTitle: "编辑展示文字",
          copyHelper: "针对当前语言编辑抬头、按钮等所有显示给用户的文字内容。",
          copyFieldLabels: {
            heroEyebrow: "信息条",
            heroTitle: "主标题",
            heroDesc: "描述 / 引言",
            previewLabel: "预览区标签",
            previewTitle: "预览区副标题",
            editorLabel: "编辑区标签",
            editorTitle: "编辑区副标题",
            scrollDown: "“下滑条”提示文案",
            addQuestion: "“新增问题”按钮",
            submit: "提交按钮"
          },
          saveChanges: "保存编辑",
          saveSuccess: "已保存到云端，可在其他设备继续编辑。",
          requiredError: "请完成所有必答题。",
          textQuestionNote: (count) =>
            count ? `已收集 ${count} 条开放回答，请在后台查看详情。` : "等待第一条开放回答。"
        },
        en: {
          toggle: "Switch to 中文",
          remove: "Remove",
          questionTitle: (index) => `Question ${index}`,
          questionPlaceholder: "Enter the prompt",
          notePlaceholder: "Optional helper text",
          optionPlaceholder: (index) => `Option ${index}`,
          adminButton: "Admin console",
          exitAdminButton: "Exit admin mode",
          adminPrompt: "Enter the admin password",
          adminError: "Incorrect password. Try again.",
          tabBuilder: "Survey builder",
          tabStats: "Response stats",
          statsLabel: "Response stats",
          statsTitle: "Overall response overview",
          statsHelper: "Track how often each option is chosen to understand response trends.",
          statsEmpty: "No submissions yet.",
          submitSuccess: "Thanks! Your feedback has been recorded.",
          responsesLabel: (count) => `${count} submissions`,
          responsesPanelLabel: "Response log",
          responsesPanelTitle: "Latest submissions",
          responsesHelper: "Pulls the 50 most recent entries from Supabase so you can review open-text answers.",
          responsesEmpty: "No submissions have been synced yet.",
          responsesRefresh: "Refresh list",
          responsesLoading: "Loading the latest submissions…",
          responsesError: "Unable to load responses. Please try again later.",
          qrLabel: "Scan to open",
          qrTitle: "QR entry point",
          qrHelper: "Share this survey anywhere—scanning the code opens the link instantly.",
          qrInputLabel: "Destination URL",
          qrRefresh: "Update QR code",
          qrNote: "Scan on mobile to open the survey",
          qrInvalid: "Please enter a valid http(s) link.",
          logoLabel: "Brand Logo",
          logoTitle: "Upload your mark",
          logoHelper: "PNG / JPG / SVG up to 2 MB. Transparent background recommended.",
          logoUpload: "Upload image",
          logoReset: "Reset to default",
          copyLabel: "Page Copy",
          copyTitle: "Edit visible text",
          copyHelper: "Adjust every piece of wording the respondent sees for the current language.",
          copyFieldLabels: {
            heroEyebrow: "Eyebrow / Tagline",
            heroTitle: "Main title",
            heroDesc: "Description",
            previewLabel: "Preview label",
            previewTitle: "Preview subtitle",
            editorLabel: "Editor label",
            editorTitle: "Editor subtitle",
            scrollDown: "\"Scroll handle\" label",
            addQuestion: "\"Add question\" button",
            submit: "Submit button"
          },
          saveChanges: "Save changes",
          saveSuccess: "Saved remotely so you can continue anywhere.",
          requiredError: "Please answer every required question.",
          textQuestionNote: (count) =>
            count
              ? `${count} open responses collected. Check the admin data for details.`
              : "Waiting for the first open response."
        }
      };

      const copyFieldConfig = [
        { id: "heroEyebrow", type: "text" },
        { id: "heroTitle", type: "text" },
        { id: "heroDesc", type: "textarea" },
        { id: "previewLabel", type: "text" },
        { id: "previewTitle", type: "text" },
        { id: "editorLabel", type: "text" },
        { id: "editorTitle", type: "text" },
        { id: "scrollDown", type: "text" },
        { id: "addQuestion", type: "text" },
        { id: "submit", type: "text" }
      ];

      const createId = () =>
        window.crypto?.randomUUID
          ? window.crypto.randomUUID()
          : `q-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;

      

      const defaultQuestions = [
        {
          id: "purchase-frequency",
          sectionId: "purchase",
          type: "single",
          required: true,
          text: { zh: "你通常多久会给宠物买一次玩具？", en: "How often do you usually buy toys for your pet?" },
          options: [
            { value: "weekly", label: { zh: "每周超过 1 次", en: "More than once a week" } },
            { value: "biweekly", label: { zh: "大约每两周一次", en: "Once every two weeks" } },
            { value: "monthly-1-2", label: { zh: "每月 1—2 次", en: "1–2 times per month" } },
            { value: "two-three-months", label: { zh: "每 2—3 个月一次", en: "Once every 2–3 months" } },
            { value: "six-month", label: { zh: "大约每 6 个月一次", en: "Once every 6 months" } },
            { value: "yearly", label: { zh: "每年一次或更少", en: "Once a year or less" } },
            { value: "mood", label: { zh: "不固定／看心情", en: "Irregular / depends on mood" } }
          ]
        },
        {
          id: "purchase-monthly-spend",
          sectionId: "purchase",
          type: "single",
          required: true,
          text: { zh: "你平均每月在宠物玩具上的花费大约是多少（美元）？", en: "Approximately how much do you spend on pet toys per month (USD)?" },
          options: [
            { value: "lt20", label: { zh: "少于 20 美元", en: "Less than $20" } },
            { value: "20-50", label: { zh: "20–50 美元", en: "$20–50" } },
            { value: "50-100", label: { zh: "50–100 美元", en: "$50–100" } },
            { value: "100-200", label: { zh: "100–200 美元", en: "$100–200" } },
            { value: "gt200", label: { zh: "超过 200 美元", en: "More than $200" } }
          ]
        },
        {
          id: "purchase-motivation",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "你购买宠物玩具的主要动机是什么？（可多选）", en: "What are your main motivations for purchasing pet toys? (Select all that apply)" },
          options: [
            { value: "replace", label: { zh: "宠物把旧玩具弄坏，需要换新的", en: "My pet breaks old toys and needs replacements" } },
            { value: "social", label: { zh: "被社交媒体或网红种草", en: "Influenced by social media or influencers" } },
            { value: "holiday", label: { zh: "节日或特殊日子的礼物", en: "Holiday or special-occasion gifts" } },
            { value: "cute", label: { zh: "觉得玩具好看／可爱", en: "I find the toys cute / aesthetically pleasing" } },
            { value: "new", label: { zh: "想让宠物尝试新东西", en: "I want my pet to try something new" } },
            { value: "motivation-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "purchase-channel",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "你通常通过哪些渠道购买宠物玩具？（可多选）", en: "Where do you usually purchase pet toys? (Select all that apply)" },
          options: [
            { value: "ecommerce", label: { zh: "电商平台（亚马逊、淘宝等）", en: "E-commerce platforms (Amazon,Taobao etc.)" } },
            { value: "local", label: { zh: "线下／本地宠物店", en: "Local pet stores" } },
            { value: "social", label: { zh: "社交平台（TikTok、Instagram、小红书等）", en: "Social media platforms (TikTok, Instagram, RedNote etc.)" } },
            { value: "brand", label: { zh: "品牌官网", en: "Brand websites" } },
            { value: "channel-other", label: { zh: "其他渠道，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "purchase-factors",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "哪些因素会降低你购买宠物玩具的意愿？（可多选）", en: "What factors affect your willingness to purchase pet toys? (Select all that apply)" },
          options: [
            { value: "price", label: { zh: "价格太高", en: "Price is too high" } },
            { value: "aesthetic", label: { zh: "与我的审美不匹配", en: "The product does not match my personal aesthetic" } },
            { value: "lose-interest", label: { zh: "担心宠物很快失去兴趣", en: "I think my pet will quickly lose interest" } },
            { value: "quality", label: { zh: "质量差／容易坏", en: "Poor quality / breaks easily" } },
            { value: "safety", label: { zh: "担心材质或气味不安全", en: "Concerns about material safety or odor" } },
            { value: "already", label: { zh: "已经买太多或家里有类似玩具", en: "Already purchased too many / similar toys at home" } },
            { value: "storage", label: { zh: "缺少收纳空间", en: "Lack of storage space" } },
            { value: "trust", label: { zh: "不信任品牌或广告", en: "Distrust of the brand or its advertising" } },
            { value: "factor-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "purchase-restraint",
          sectionId: "purchase",
          type: "multi",
          required: true,
          text: { zh: "在什么情况下你会克制自己不再购买玩具？（可多选）", en: "In what situations do you usually control or restrain your desire to buy toys? (Select all that apply)" },
          options: [
            { value: "spent-too-much", label: { zh: "最近已经花太多钱", en: "Feeling like I’ve spent too much recently" } },
            { value: "pet-doesnt-need", label: { zh: "觉得宠物其实不需要新玩具", en: "My pet does not truly need a new toy" } },
            { value: "friends-remind", label: { zh: "被亲友提醒理性消费", en: "Reminded by friends/family to spend rationally" } },
            { value: "reviews", label: { zh: "看评论或实物后觉得不值", en: "Product reviews or inspections make it seem not worth it" } },
            { value: "environment", label: { zh: "环保或可持续的考量", en: "Environmental or sustainability concerns" } },
            { value: "restraint-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "usage-interest-time",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "你的宠物平均多久会对一个玩具失去兴趣？", en: "On average, how long does it take for your pet to lose interest in a toy?" },
          options: [
            { value: "hours", label: { zh: "几小时内", en: "Within a few hours" } },
            { value: "days", label: { zh: "1—3 天内", en: "Within 1–3 days" } },
            { value: "week", label: { zh: "大约 1 周", en: "About 1 week" } },
            { value: "month", label: { zh: "大约 1 个月", en: "About 1 month" } },
            { value: "3months", label: { zh: "3 个月后仍感兴趣", en: "Still interested after 3 months" } },
            { value: "depends", label: { zh: "取决于玩具类型", en: "Depends on the type of toy" } },
            { value: "unsure", label: { zh: "不确定／没留意", en: "Not sure / haven’t noticed" } }
          ]
        },
        {
          id: "usage-damage-time",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "宠物玩具平均多久会被玩坏？", en: "On average, how long does it take for your pet’s toys to become damaged?" },
          options: [
            { value: "hours", label: { zh: "几小时内", en: "Within a few hours" } },
            { value: "days", label: { zh: "1—3 天内", en: "Within 1–3 days" } },
            { value: "week", label: { zh: "大约 1 周", en: "About 1 week" } },
            { value: "month", label: { zh: "大约 1 个月", en: "About 1 month" } },
            { value: "3months", label: { zh: "3 个月后仍可使用", en: "Still usable after 3 months" } },
            { value: "depends", label: { zh: "取决于玩具类型", en: "Depends on the type of toy" } },
            { value: "unsure", label: { zh: "不确定／没留意", en: "Not sure / haven’t noticed" } }
          ]
        },
        {
          id: "usage-toy-count",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "你的宠物目前大概有多少个玩具？", en: "How many toys does your pet currently have?" },
          options: [
            { value: "1-3", label: { zh: "1—3 个", en: "1–3" } },
            { value: "4-6", label: { zh: "4—6 个", en: "4–6" } },
            { value: "7-10", label: { zh: "7—10 个", en: "7–10" } },
            { value: "10+", label: { zh: "超过 10 个", en: "More than 10" } }
          ]
        },
        {
          id: "usage-favorite-share",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "你的宠物经常玩的玩具大概占总数的多少？", en: "What percentage of the toys does your pet frequently play with?" },
          options: [
            { value: "80plus", label: { zh: "80% 以上", en: "Over 80%" } },
            { value: "half", label: { zh: "大约一半", en: "About half" } },
            { value: "less-half", label: { zh: "少于一半", en: "Less than half" } },
            { value: "few-favorites", label: { zh: "只有一两个最喜欢的", en: "Only one or two favorites" } }
          ]
        },
        {
          id: "usage-unused",
          sectionId: "usage",
          type: "multi",
          required: true,
          text: { zh: "对于闲置的玩具，你通常如何处理？（可多选）", en: "How do you usually handle unused toys? (Select all that apply)" },
          options: [
            { value: "discard", label: { zh: "直接丢掉", en: "Throw them away" } },
            { value: "store", label: { zh: "收起来不用", en: "Store them without using" } },
            { value: "repurpose", label: { zh: "改造成其他玩具", en: "Repurpose into other toys" } },
            { value: "clean", label: { zh: "清洗后继续使用", en: "Clean and reuse" } },
            { value: "donate", label: { zh: "赠送或捐出去", en: "Give away / donate" } },
            { value: "unused-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "usage-damaged",
          sectionId: "usage",
          type: "multi",
          required: true,
          text: { zh: "对于损坏的玩具，你通常如何处理？（可多选）", en: "How do you usually handle damaged toys? (Select all that apply)" },
          options: [
            { value: "discard", label: { zh: "直接丢掉", en: "Throw them away" } },
            { value: "store", label: { zh: "收起来不用", en: "Store them without using" } },
            { value: "repurpose", label: { zh: "改造成别的东西", en: "Repurpose into other toys" } },
            { value: "clean", label: { zh: "清洗修补后再用", en: "Clean and reuse" } },
            { value: "donate", label: { zh: "赠送或捐出去", en: "Give away / donate" } },
            { value: "damaged-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "diy-willingness",
          sectionId: "usage",
          type: "single",
          required: true,
          text: { zh: "你愿意亲手为宠物制作玩具吗？", en: "Are you willing to make DIY toys for your pet?" },
          options: [
            { value: "very", label: { zh: "非常愿意——我喜欢动手", en: "Very willing — I enjoy crafting" } },
            { value: "with-guide", label: { zh: "愿意，但需要教程或指导", en: "Willing, but only with tutorials/guidance" } },
            { value: "concerned", label: { zh: "有兴趣但担心安全或宠物不喜欢", en: "I’m interested, but concerned about safety or pet disliking it" } },
            { value: "not-enjoy", label: { zh: "有兴趣但不太喜欢手作", en: "I’m interested, but don’t enjoy crafting" } }
          ]
        },
        {
          id: "sustain-awareness",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "你是否听说过“可持续”或“环保”的宠物玩具？", en: "Have you heard of “sustainable pet products” or “eco-friendly pet toys”?" },
          options: [
            { value: "aware", label: { zh: "听说过并了解", en: "Yes, and I understand the concept" } },
            { value: "heard", label: { zh: "听说过但了解不多", en: "Yes, but I do not understand much about it" } },
            { value: "learn", label: { zh: "没听说过，但想进一步了解", en: "No,but want to learn more" } },
            { value: "not-interested", label: { zh: "没听过，也不太感兴趣", en: "No, not interested in it at all" } }
          ]
        },
        {
          id: "sustain-importance",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "在选择宠物玩具时，你觉得环保或可回收材料有多重要？", en: "How important do you think eco-friendly or recyclable materials are when choosing pet toys?" },
          options: [
            { value: "very", label: { zh: "非常重要", en: "Very important" } },
            { value: "somewhat", label: { zh: "比较重要", en: "Somewhat important" } },
            { value: "neutral", label: { zh: "一般／中立", en: "Neutral" } },
            { value: "not-very", label: { zh: "不太重要", en: "Not very important" } },
            { value: "not-at-all", label: { zh: "完全不重要", en: "Not important at all" } }
          ]
        },
        {
          id: "sustain-premium",
          sectionId: "sustainability",
          type: "single",
          required: true,
          text: { zh: "如果环保玩具比普通玩具稍贵，你会愿意购买吗？", en: "If eco-friendly pet toys cost slightly higher than regular ones, would you be willing to purchase them?" },
          options: [
            { value: "yes", label: { zh: "愿意", en: "Yes" } },
            { value: "depends", label: { zh: "视情况而定", en: "Depends on the situation" } },
            { value: "no", label: { zh: "不会购买", en: "No" } }
          ]
        },
        {
          id: "reuse-participation",
          sectionId: "reuse",
          type: "single",
          required: true,
          text: { zh: "如果有品牌或平台提供玩具回收、翻新或捐赠服务，你会参加吗？", en: "If a brand or platform offered toy recycling,/refurbishing,/ or donation services, would you participate?" },
          options: [
            { value: "definitely", label: { zh: "一定会", en: "Definitely" } },
            { value: "probably", label: { zh: "可能会", en: "Probably" } },
            { value: "depends", label: { zh: "看情况", en: "Depends" } },
            { value: "no", label: { zh: "不会", en: "No" } }
          ]
        },
        {
          id: "reuse-factors",
          sectionId: "reuse",
          type: "multi",
          required: true,
          text: { zh: "哪些因素会影响你是否参加玩具再利用计划？（可多选）", en: "What factors influence your willingness to participate in toy reuse programs? (Select all that apply)" },
          options: [
            { value: "convenience", label: { zh: "收集点是否方便", en: "Convenience (easily accessible drop-off points)" } },
            { value: "hygiene", label: { zh: "卫生与安全疑虑", en: "Hygiene and safety concerns" } },
            { value: "quantity", label: { zh: "家中闲置玩具数量", en: "Number of unused toys at home" } },
            { value: "fees", label: { zh: "服务费用", en: "Service fees" } },
            { value: "trust", label: { zh: "对机构的信任度", en: "Trust in the organization" } },
            { value: "rewards", label: { zh: "是否有奖励或优惠", en: "Rewards or incentives" } },
            { value: "responsibility", label: { zh: "环保或社会责任感", en: "Environmental or social responsibility awareness" } },
            { value: "reuse-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "reuse-redesign",
          sectionId: "reuse",
          type: "single",
          required: true,
          text: { zh: "如果旧玩具被重新设计成配饰或装饰品，你会考虑使用或购买吗？", en: "If old toys were redesigned into new products (e.g., pet accessories or decorative items), would you consider using or purchasing them?" },
          options: [
            { value: "very", label: { zh: "非常愿意", en: "Very willing" } },
            { value: "interested", label: { zh: "有点兴趣", en: "Somewhat interested" } },
            { value: "not-willing", label: { zh: "不太愿意", en: "Not very willing" } },
            { value: "not-interested", label: { zh: "完全没兴趣", en: "Not interested at all" } }
          ]
        },
        {
          id: "basic-pet-type",
          sectionId: "basic",
          type: "multi",
          required: true,
          text: { zh: "你养的宠物类型及数量是？", en: "What type(s) of pets do you have, and how many?" },
          options: [
            { value: "dog", label: { zh: "狗：", en: "Dog(s):" }, hasTextInput: true, placeholder: { zh: "填写数量", en: "Enter number" } },
            { value: "cat", label: { zh: "猫：", en: "Cat(s):" }, hasTextInput: true, placeholder: { zh: "填写数量", en: "Enter number" } }
          ]
        },
        {
          id: "basic-age",
          sectionId: "basic",
          type: "single",
          required: true,
          text: { zh: "你的年龄范围是？", en: "What is your age range?" },
          options: [
            { value: "18-23", label: { zh: "18–23 岁", en: "18–23" } },
            { value: "23-30", label: { zh: "23–30 岁", en: "23–30" } },
            { value: "30-36", label: { zh: "30–36 岁", en: "30–36" } },
            { value: "36-44", label: { zh: "36–44 岁", en: "36–44" } }
          ]
        },
        {
          id: "basic-occupation",
          sectionId: "basic",
          type: "multi",
          required: true,
          text: { zh: "你目前的身份或职业是？（可多选）", en: "What is your current occupation or status? (Select all that apply)" },
          options: [
            { value: "student", label: { zh: "学生", en: "Student" } },
            { value: "fulltime", label: { zh: "上班族／全职工作", en: "Full-time employee" } },
            { value: "freelancer", label: { zh: "自由职业者", en: "Freelancer" } },
            { value: "occupation-other", label: { zh: "其他，请说明", en: "Other (please specify)" }, hasTextInput: true, placeholder: { zh: "请填写", en: "Please specify" } }
          ]
        },
        {
          id: "open-waste",
          sectionId: "open",
          type: "text",
          required: false,
          text: { zh: "你觉得目前宠物玩具最浪费或最不环保的地方是什么？", en: "In your opinion, what aspects of current pet toys are the most wasteful or unsustainable?" },
          placeholder: { zh: "简短回答", en: "Short answer" }
        },
        {
          id: "open-innovation",
          sectionId: "open",
          type: "text",
          required: false,
          text: { zh: "你希望未来的宠物玩具有哪些改进或创新？", en: "What improvements or innovations would you like to see in future pet toys?" },
          placeholder: { zh: "简短回答", en: "Short answer" }
        },
        {
          id: "open-diy-barrier",
          sectionId: "open",
          type: "text",
          required: false,
          text: { zh: "是什么最阻碍你亲手 DIY 宠物玩具？", en: "What currently discourages you the most from DIY-ing pet toys?" },
          placeholder: { zh: "简短回答", en: "Short answer" }
        },
        {
          id: "open-email",
          sectionId: "open",
          type: "text",
          required: false,
          text: { zh: "如果愿意接受后续简短访谈，请留下邮箱（可选）", en: "Would you be open to a short interview in the future? If yes, please share your email address. Thank you!" },
          placeholder: { zh: "电子邮箱（可选）", en: "Your email (optional)" }
        }
      ];


      const defaultContent = {
        zh: {
          heroEyebrow: "Live Survey Builder",
          heroTitle: "宠物玩具与可持续问卷",
          heroDesc:
            "支持长列表题目、中英文切换、二维码分享与云端保存，帮助团队随时联合作业、实时发布更新。",
          previewLabel: "问卷预览",
          previewTitle: "受访者看到的样子",
          editorLabel: "编辑区",
          editorTitle: "实时更新问题与选项",
          scrollDown: "拖动滑条查看更多问题",
          addQuestion: "新增问题",
          submit: "提交问卷"
        },
        en: {
          heroEyebrow: "Live Survey Builder",
          heroTitle: "Pet Toy Sustainability Survey",
          heroDesc:
            "Manage a bilingual questionnaire with live preview, QR sharing, and collaborative cloud saves for the whole team.",
          previewLabel: "Preview",
          previewTitle: "What participants will see",
          editorLabel: "Editor",
          editorTitle: "Update questions & options",
          scrollDown: "Drag to scroll questions",
          addQuestion: "Add question",
          submit: "Submit survey"
        }
      };

      const runtimeConfig = window.__SURVEY_CONFIG__ || {};
      const DEFAULT_LOGO_SRC = "./assets/logo.svg";
      const LOGO_STORAGE_KEY = "survey-builder-logo";
      const LOGO_MAX_BYTES = 2 * 1024 * 1024;
      const QR_URL_STORAGE_KEY = "survey-builder-qr-url";
      const DEFAULT_QR_URL = runtimeConfig.defaultQrUrl || "https://hanyangzhang001-svg.github.io/HANYANG/";
      const ADMIN_PASSWORD = runtimeConfig.adminPassword || "";
      const ADMIN_MODE_KEY = "survey-builder-admin-mode";
      const STORAGE_QUESTIONS_KEY = "survey-builder-questions";
      const STORAGE_CONTENT_KEY = "survey-builder-content";
      const SUPABASE_URL = runtimeConfig.supabaseUrl;
      const SUPABASE_KEY = runtimeConfig.supabaseKey;
      const REMOTE_SYNC_ENABLED = Boolean(SUPABASE_URL && SUPABASE_KEY);
      const RESPONSE_FETCH_LIMIT = 50;
      const STATS_FETCH_LIMIT = 500;
      const SUPABASE_CONFIG_ENDPOINT = REMOTE_SYNC_ENABLED ? `${SUPABASE_URL}/rest/v1/survey_configs` : null;
      const SUPABASE_RESPONSES_ENDPOINT = REMOTE_SYNC_ENABLED ? `${SUPABASE_URL}/rest/v1/survey_responses` : null;
      const SUPABASE_CONFIG_ID = "main";

      const persistQuestions = () => {
        try {
          localStorage.setItem(STORAGE_QUESTIONS_KEY, JSON.stringify(questions));
        } catch (error) {
          console.warn("Unable to store questions", error);
        }
      };

      const persistContent = () => {
        try {
          localStorage.setItem(STORAGE_CONTENT_KEY, JSON.stringify(contentText));
        } catch (error) {
          console.warn("Unable to store content text", error);
        }
      };

      const supabaseHeaders = REMOTE_SYNC_ENABLED
        ? {
            apikey: SUPABASE_KEY,
            Authorization: `Bearer ${SUPABASE_KEY}`,
            "Content-Type": "application/json"
          }
        : null;
      // Extra headers for config read/write; pairs with RLS policy that checks x-admin-key
      const supabaseConfigHeaders =
        supabaseHeaders && ADMIN_PASSWORD
          ? { ...supabaseHeaders, "x-admin-key": ADMIN_PASSWORD }
          : supabaseHeaders;
      // Admin-only headers for reading responses/stats; requires matching RLS on survey_responses
      const supabaseAdminHeaders =
        supabaseHeaders && ADMIN_PASSWORD
          ? { ...supabaseHeaders, "x-admin-key": ADMIN_PASSWORD }
          : supabaseHeaders;

      const fetchRemoteConfig = async () => {
        if (!REMOTE_SYNC_ENABLED) {
          return null;
        }
        try {
          const response = await fetch(
            `${SUPABASE_CONFIG_ENDPOINT}?id=eq.${SUPABASE_CONFIG_ID}&select=config`,
            {
              headers: supabaseConfigHeaders || {}
            }
          );
          if (!response.ok) throw new Error("Failed to fetch remote config");
          const data = await response.json();
          return data[0]?.config || null;
        } catch (error) {
          console.warn("Unable to fetch remote config", error);
          return null;
        }
      };

      const saveRemoteConfig = async (payload) => {
        if (!REMOTE_SYNC_ENABLED) {
          return null;
        }
        try {
          const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/save_survey_config`, {
            method: "POST",
            headers: {
              ...(supabaseHeaders || {}),
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              payload,
              admin_key: ADMIN_PASSWORD
            })
          });
          if (!response.ok) throw new Error("Failed to save remote config");
          const raw = await response.text();
          if (!raw) {
            return null;
          }
          return JSON.parse(raw);
        } catch (error) {
          console.error("Unable to save remote config", error);
          throw error;
        }
      };

      const saveResponseSubmission = async (answers) => {
        if (!REMOTE_SYNC_ENABLED || !SUPABASE_RESPONSES_ENDPOINT) {
          return;
        }
        try {
          await fetch(SUPABASE_RESPONSES_ENDPOINT, {
            method: "POST",
            headers: supabaseHeaders,
            body: JSON.stringify({
              answers,
              submitted_at: new Date().toISOString()
            })
          });
        } catch (error) {
          console.warn("Unable to persist response", error);
        }
      };

      const loadStoredQrUrl = () => {
        try {
          return localStorage.getItem(QR_URL_STORAGE_KEY);
        } catch (error) {
          console.warn("Unable to load QR url", error);
          return null;
        }
      };

      const persistQrUrl = (url) => {
        try {
          localStorage.setItem(QR_URL_STORAGE_KEY, url);
        } catch (error) {
          console.warn("Unable to store QR url", error);
        }
      };

      let currentLanguage = "en";
      let currentScreen = "builder";
      const loadSavedQuestions = () => {
        try {
          const stored = localStorage.getItem(STORAGE_QUESTIONS_KEY);
          if (!stored) return null;
          const parsed = JSON.parse(stored);
          return Array.isArray(parsed) && parsed.length ? parsed : null;
        } catch (error) {
          console.warn("Unable to load saved questions", error);
          return null;
        }
      };

      const loadSavedContent = () => {
        try {
          const stored = localStorage.getItem(STORAGE_CONTENT_KEY);
          if (!stored) return null;
          const parsed = JSON.parse(stored);
          if (!parsed || typeof parsed !== "object") return null;
          return parsed;
        } catch (error) {
          console.warn("Unable to load saved content", error);
          return null;
        }
      };

      const findSectionById = (sectionId) => questionSections.find((section) => section.id === sectionId);

      const findOptionByValue = (question, value) =>
        question?.options?.find((option) => option.value === value);

      const isValidQuestionSet = (list) =>
        Array.isArray(list) &&
        list.every(
          (item) =>
            typeof item === "object" &&
            item !== null &&
            item.id &&
            item.sectionId &&
            item.type &&
            item.text
        );

      const findQuestionById = (id) => questions.find((question) => question.id === id);

      let questions = loadSavedQuestions();
      if (!isValidQuestionSet(questions)) {
        questions = JSON.parse(JSON.stringify(defaultQuestions));
      }
      let contentText = loadSavedContent() || JSON.parse(JSON.stringify(defaultContent));
      let currentLogoDataUrl = null;
      let currentQrUrl = "";
      let adminEnabled = false;
      let responseFeedItems = [];
      let responseFeedLoading = false;
      let responseFeedError = null;
      let statsLoading = false;
      let statsError = null;
      let cloudTotals = {};
      let cloudSubmissionCount = 0;
      let cloudLastUpdated = null;

      const ui = {
        logoImage: document.querySelector(".hero-logo"),
        heroEyebrow: document.getElementById("hero-eyebrow"),
        heroTitle: document.getElementById("hero-title"),
        heroDesc: document.getElementById("hero-desc"),
        previewLabel: document.getElementById("preview-label"),
        previewTitle: document.getElementById("preview-title"),
        editorLabel: document.getElementById("editor-label"),
        editorTitle: document.getElementById("editor-title"),
        logoLabel: document.getElementById("logo-label"),
        logoTitle: document.getElementById("logo-title"),
        logoHelper: document.getElementById("logo-helper"),
        logoUploadText: document.getElementById("logo-upload-text"),
        logoResetButton: document.getElementById("logo-reset"),
        logoInput: document.getElementById("logo-input"),
        scrollDownLabel: document.getElementById("scroll-editor-label"),
        scrollRange: document.getElementById("scroll-editor-range"),
        addQuestion: document.getElementById("add-question"),
        submit: document.getElementById("submit-btn"),
        langToggle: document.getElementById("lang-toggle"),
        builderTab: document.getElementById("tab-builder"),
        statsTab: document.getElementById("tab-stats"),
        builderView: document.getElementById("builder-view"),
        statsView: document.getElementById("stats-view"),
        statsLabel: document.getElementById("stats-label"),
        statsTitle: document.getElementById("stats-title"),
        statsHelper: document.getElementById("stats-helper"),
        statsContent: document.getElementById("stats-content"),
        statsEmpty: document.getElementById("stats-empty"),
        responsesLabel: document.getElementById("responses-label"),
        responsesTitle: document.getElementById("responses-title"),
        responsesHelper: document.getElementById("responses-helper"),
        responsesEmpty: document.getElementById("response-empty"),
        responsesFeed: document.getElementById("response-feed"),
        responseRefresh: document.getElementById("response-refresh"),
        editorPanel: document.querySelector(".editor-panel"),
        qrLabel: document.getElementById("qr-label"),
        qrTitle: document.getElementById("qr-title"),
        qrHelper: document.getElementById("qr-helper"),
        qrInputLabel: document.getElementById("qr-input-label"),
        qrRefresh: document.getElementById("qr-refresh"),
        qrNote: document.getElementById("qr-note"),
        qrUrlInput: document.getElementById("qr-url"),
        qrCode: document.getElementById("qr-code"),
        adminButton: document.getElementById("admin-button"),
        exitAdminButton: document.getElementById("exit-admin-button"),
        saveButton: document.getElementById("save-editor")
      };

      const questionList = document.getElementById("question-list");
      const editorList = document.getElementById("editor-list");
      const copyEditor = document.getElementById("copy-editor");

      const isValidUrl = (value) => {
        if (!value) return false;
        try {
          const parsed = new URL(value);
          return parsed.protocol === "http:" || parsed.protocol === "https:";
        } catch (error) {
          return false;
        }
      };

      const renderQrCode = (value) => {
        if (!ui.qrCode) return;
        const img = document.createElement("img");
        img.alt = "二维码";
        img.width = 180;
        img.height = 180;
        img.src = `https://quickchart.io/qr?size=220&text=${encodeURIComponent(value)}`;
        img.referrerPolicy = "no-referrer";
        ui.qrCode.innerHTML = "";
        ui.qrCode.appendChild(img);
        currentQrUrl = value;
      };

      const initQrSection = () => {
        if (!ui.qrUrlInput) return;
        let initialUrl = currentQrUrl;
        if (!initialUrl) {
          const stored = loadStoredQrUrl();
          initialUrl = stored && isValidUrl(stored) ? stored : DEFAULT_QR_URL || window.location.href;
        }
        ui.qrUrlInput.value = initialUrl;
        persistQrUrl(initialUrl);
        renderQrCode(initialUrl);
        setQrEditable(adminEnabled);
      };

      const updateQrFromInput = () => {
        if (!adminEnabled) {
          return;
        }
        if (!ui.qrUrlInput) return;
        const url = ui.qrUrlInput.value.trim();
        const meta = uiMeta[currentLanguage];
        if (!isValidUrl(url)) {
          alert(meta.qrInvalid);
          ui.qrUrlInput.focus();
          return;
        }
        persistQrUrl(url);
        renderQrCode(url);
      };

      const enableAdminMode = () => {
        if (adminEnabled || !ADMIN_PASSWORD) return;
        adminEnabled = true;
        document.body.classList.add("admin-mode");
        if (ui.editorPanel) {
          ui.editorPanel.hidden = false;
          ui.editorPanel.setAttribute("aria-hidden", "false");
        }
        if (ui.exitAdminButton) {
          ui.exitAdminButton.hidden = false;
        }
        sessionStorage.setItem(ADMIN_MODE_KEY, "true");
        const url = new URL(window.location.href);
        url.searchParams.delete("admin");
        window.history.replaceState({}, "", url.toString());
        setQrEditable(true);
        setStatsVisibility(true);
        renderStats();
        loadCloudStats();
        loadResponseFeed();
      };

      const disableAdminMode = () => {
        adminEnabled = false;
        document.body.classList.remove("admin-mode");
        if (ui.editorPanel) {
          ui.editorPanel.hidden = true;
          ui.editorPanel.setAttribute("aria-hidden", "true");
        }
        if (ui.exitAdminButton) {
          ui.exitAdminButton.hidden = true;
        }
        sessionStorage.removeItem(ADMIN_MODE_KEY);
        const url = new URL(window.location.href);
        url.searchParams.delete("admin");
        window.history.replaceState({}, "", url.toString());
        setQrEditable(false);
        switchScreen("builder");
      };

      const setText = (el, value) => {
        if (el) {
          el.textContent = value;
        }
      };

      const setQrEditable = (editable) => {
        if (ui.qrUrlInput) {
          ui.qrUrlInput.disabled = !editable;
          ui.qrUrlInput.readOnly = !editable;
        }
        if (ui.qrRefresh) {
          ui.qrRefresh.disabled = !editable;
        }
      };

      const applyLogoSrc = (src) => {
        if (ui.logoImage) {
          ui.logoImage.src = src || DEFAULT_LOGO_SRC;
        }
      };

      const formatTimestamp = (value) => {
        if (!value) return "";
        try {
          const date = new Date(value);
          return new Intl.DateTimeFormat(currentLanguage === "zh" ? "zh-CN" : "en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit"
          }).format(date);
        } catch (error) {
          return value;
        }
      };

      const describeAnswer = (question, answerPayload) => {
        if (!question) {
          return typeof answerPayload === "string" ? answerPayload : "";
        }
        if (answerPayload === null || answerPayload === undefined) {
          return "";
        }
        if (typeof answerPayload === "string") {
          const option = findOptionByValue(question, answerPayload);
          return option?.label?.[currentLanguage] || answerPayload;
        }
        if (Array.isArray(answerPayload)) {
          return answerPayload
            .map((value) => findOptionByValue(question, value)?.label?.[currentLanguage] || value)
            .join(" / ");
        }
        switch (answerPayload.type) {
          case "single": {
            const option = findOptionByValue(question, answerPayload.selection);
            let textValue = option?.label?.[currentLanguage] || answerPayload.selection || "";
            if (answerPayload.otherText) {
              textValue += currentLanguage === "zh" ? `（补充：${answerPayload.otherText}）` : ` (note: ${answerPayload.otherText})`;
            }
            return textValue;
          }
          case "multi": {
            const selections = Array.isArray(answerPayload.selections) ? answerPayload.selections : [];
            const pieces = selections.map((value) => {
              const option = findOptionByValue(question, value);
              let label = option?.label?.[currentLanguage] || value;
              const extra = answerPayload.otherText?.[value];
              if (extra) {
                label += currentLanguage === "zh" ? `（补充：${extra}）` : ` (note: ${extra})`;
              }
              return label;
            });
            return pieces.join(" / ");
          }
          case "text":
            return answerPayload.text || "";
          default:
            return JSON.stringify(answerPayload);
        }
      };

      const aggregateCloudTotals = (records) => {
        const totals = {};
        records.forEach((record) => {
          const answers = record.answers || {};
          Object.entries(answers).forEach(([questionId, payload]) => {
            const question = questions.find((item) => item.id === questionId);
            if (!question || !payload) return;
            if (question.type === "single") {
              totals[questionId] = totals[questionId] || {};
              const selection = payload.selection;
              if (!selection) return;
              totals[questionId][selection] = (totals[questionId][selection] || 0) + 1;
            } else if (question.type === "multi") {
              totals[questionId] = totals[questionId] || {};
              (payload.selections || []).forEach((selection) => {
                totals[questionId][selection] = (totals[questionId][selection] || 0) + 1;
              });
            } else if (question.type === "text") {
              totals[questionId] = totals[questionId] || { __textCount: 0 };
              totals[questionId].__textCount = (totals[questionId].__textCount || 0) + 1;
            }
          });
        });
        return totals;
      };

      const loadStoredLogo = () => {
        try {
          const stored = localStorage.getItem(LOGO_STORAGE_KEY);
          if (stored) {
            currentLogoDataUrl = stored;
            applyLogoSrc(stored);
            return;
          }
        } catch (error) {
          console.warn("Unable to read stored logo", error);
        }
        currentLogoDataUrl = null;
        applyLogoSrc(DEFAULT_LOGO_SRC);
      };

      const persistLogo = (dataUrl) => {
        try {
          if (dataUrl) {
            localStorage.setItem(LOGO_STORAGE_KEY, dataUrl);
          } else {
            localStorage.removeItem(LOGO_STORAGE_KEY);
          }
        } catch (error) {
          console.warn("Unable to persist logo", error);
        }
      };

      const syncScrollHandle = () => {
        if (!editorList || !ui.scrollRange) return;
        const maxScroll = editorList.scrollHeight - editorList.clientHeight;
        const disabled = maxScroll <= 2;
        ui.scrollRange.disabled = disabled;
        if (disabled) {
          ui.scrollRange.value = 0;
          return;
        }
        const progress = (editorList.scrollTop / maxScroll) * 100;
        ui.scrollRange.value = progress;
      };

      const createQuestionElement = (question) => {
        const block = document.createElement("article");
        block.className = "question";
        block.dataset.questionId = question.id;

        const head = document.createElement("div");
        head.className = "question-head";
        const title = document.createElement("h3");
        title.className = "question-title";
        title.textContent = question.text?.[currentLanguage] || "";
        head.appendChild(title);
        if (question.required) {
          const required = document.createElement("span");
          required.className = "question-required";
          required.textContent = currentLanguage === "zh" ? "必答" : "Required";
          head.appendChild(required);
        }
        block.appendChild(head);

        const descriptionText = question.description?.[currentLanguage];
        if (descriptionText) {
          const description = document.createElement("p");
          description.className = "question-description";
          description.textContent = descriptionText;
          block.appendChild(description);
        }

        if (question.type === "text") {
          const textarea = document.createElement("textarea");
          textarea.name = question.id;
          textarea.required = Boolean(question.required);
          textarea.placeholder = question.placeholder?.[currentLanguage] || "";
          textarea.rows = question.longAnswer ? 4 : 3;
          block.appendChild(textarea);
          return block;
        }

        const optionsWrap = document.createElement("div");
        optionsWrap.className = "options";
        (question.options || []).forEach((option, index) => {
          const label = document.createElement("label");
          label.className = "option";

          const input = document.createElement("input");
          input.type = question.type === "multi" ? "checkbox" : "radio";
          input.name = question.id;
          input.value = option.value;
          if (question.type === "single" && question.required) {
            input.required = true;
          }

          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = index + 1;

          const optionText = document.createElement("span");
          optionText.className = "option-text";
          optionText.textContent = option.label?.[currentLanguage] || "";

          label.appendChild(input);
          label.appendChild(badge);
          label.appendChild(optionText);

          if (option.hasTextInput) {
            const extraInput = document.createElement("input");
            extraInput.type = "text";
            extraInput.className = "option-extra";
            extraInput.name = `${question.id}__${option.value}__text`;
            extraInput.placeholder = option.placeholder?.[currentLanguage] || "";
            extraInput.disabled = true;
            label.appendChild(extraInput);
            const syncExtraInput = () => {
              const active = question.type === "multi" ? input.checked : input.checked;
              extraInput.disabled = !active;
              extraInput.required = active;
              if (!active) {
                extraInput.value = "";
              }
            };
            input.addEventListener("change", syncExtraInput);
          }

          optionsWrap.appendChild(label);
        });
        block.appendChild(optionsWrap);
        return block;
      };

      const renderPreview = () => {
        if (!questionList) return;
        questionList.innerHTML = "";

        const intro = surveyIntro[currentLanguage];
        if (intro) {
          const introBlock = document.createElement("section");
          introBlock.className = "survey-intro";
          const introTitle = document.createElement("h2");
          introTitle.textContent = intro.title;
          introBlock.appendChild(introTitle);
          intro.description?.forEach((paragraph) => {
            const p = document.createElement("p");
            p.textContent = paragraph;
            introBlock.appendChild(p);
          });
          questionList.appendChild(introBlock);
        }

        questionSections.forEach((section) => {
          const sectionQuestions = questions.filter((question) => question.sectionId === section.id);
          if (!sectionQuestions.length) return;
          const sectionBlock = document.createElement("div");
          sectionBlock.className = "question-section";
          const heading = document.createElement("h3");
          heading.textContent = section[currentLanguage].title;
          sectionBlock.appendChild(heading);
          const summary = section[currentLanguage].summary;
          if (summary) {
            const summaryNode = document.createElement("p");
            summaryNode.className = "question-description";
            summaryNode.textContent = summary;
            sectionBlock.appendChild(summaryNode);
          }
          sectionQuestions.forEach((question) => {
            sectionBlock.appendChild(createQuestionElement(question));
          });
          questionList.appendChild(sectionBlock);
        });
      };

      const renderEditor = () => {
        if (!editorList) return;
        const meta = uiMeta[currentLanguage];
        editorList.innerHTML = "";
        questions.forEach((question, index) => {
          question.text = question.text || { zh: "", en: "" };
          question.description = question.description || { zh: "", en: "" };
          const card = document.createElement("article");
          card.className = "editor-card";

          const head = document.createElement("header");
          const title = document.createElement("h3");
          const sectionTitle = findSectionById(question.sectionId)?.[currentLanguage]?.title || "";
          title.textContent = `${meta.questionTitle(index + 1)} · ${sectionTitle}`;

          const removeButton = document.createElement("button");
          removeButton.className = "remove";
          removeButton.type = "button";
          removeButton.textContent = meta.remove;
          removeButton.addEventListener("click", () => {
            questions = questions.filter((item) => item.id !== question.id);
            renderEditor();
            renderPreview();
            renderStats();
          });

          head.appendChild(title);
          head.appendChild(removeButton);
          card.appendChild(head);

          const questionLabel = document.createElement("label");
          const questionSpan = document.createElement("span");
          questionSpan.textContent = meta.questionPlaceholder;
          const questionInput = document.createElement("textarea");
          questionInput.value = question.text[currentLanguage] || "";
          questionInput.addEventListener("input", (event) => {
            question.text[currentLanguage] = event.target.value;
            renderPreview();
            renderStats();
          });
          questionLabel.appendChild(questionSpan);
          questionLabel.appendChild(questionInput);
          card.appendChild(questionLabel);

          const noteLabel = document.createElement("label");
          const noteSpan = document.createElement("span");
          noteSpan.textContent = meta.notePlaceholder;
          const noteInput = document.createElement("input");
          noteInput.type = "text";
          noteInput.value = question.description[currentLanguage] || "";
          noteInput.placeholder = meta.notePlaceholder;
          noteInput.addEventListener("input", (event) => {
            question.description[currentLanguage] = event.target.value;
            renderPreview();
          });
          noteLabel.appendChild(noteSpan);
          noteLabel.appendChild(noteInput);
          card.appendChild(noteLabel);

          if (Array.isArray(question.options)) {
            question.options.forEach((option, optionIndex) => {
              option.label = option.label || { zh: "", en: "" };
              const optionLabel = document.createElement("label");
              const labelSpan = document.createElement("span");
              labelSpan.textContent = meta.optionPlaceholder(optionIndex + 1);
              const optionInput = document.createElement("input");
              optionInput.type = "text";
              optionInput.value = option.label[currentLanguage] || "";
              optionInput.addEventListener("input", (event) => {
                option.label[currentLanguage] = event.target.value;
                renderPreview();
                renderStats();
              });
              optionLabel.appendChild(labelSpan);
              optionLabel.appendChild(optionInput);
              card.appendChild(optionLabel);
            });
          }

          editorList.appendChild(card);
        });

        syncScrollHandle();
      };

      const renderStats = () => {
        if (!ui.statsContent) return;
        const meta = uiMeta[currentLanguage];
        if (statsLoading) {
          const loadingText = currentLanguage === "zh" ? "云端统计加载中…" : "Syncing latest data…";
          ui.statsContent.innerHTML = `<p class="loader">${loadingText}</p>`;
          if (ui.statsHelper) {
            ui.statsHelper.textContent = meta.statsHelper;
          }
          ui.statsEmpty.hidden = true;
          return;
        }
        if (statsError) {
          ui.statsContent.innerHTML = `<p class="error">${statsError.message || "Unable to load cloud stats"}</p>`;
          if (ui.statsHelper) {
            ui.statsHelper.textContent = meta.statsHelper;
          }
          return;
        }
        if (ui.statsHelper) {
          ui.statsHelper.textContent = cloudLastUpdated
            ? `${meta.statsHelper} · Last synced ${formatTimestamp(cloudLastUpdated)}`
            : meta.statsHelper;
        }
        if (!cloudSubmissionCount) {
          ui.statsContent.innerHTML = "";
          if (ui.statsEmpty) {
            ui.statsEmpty.hidden = false;
            ui.statsEmpty.textContent = meta.statsEmpty;
          }
          return;
        }
        if (ui.statsEmpty) {
          ui.statsEmpty.hidden = true;
        }
        ui.statsContent.innerHTML = "";
        questionSections.forEach((section) => {
          const sectionQuestions = questions.filter((question) => question.sectionId === section.id);
          if (!sectionQuestions.length) return;
          const sectionBlock = document.createElement("div");
          sectionBlock.className = "stats-section";
          const heading = document.createElement("h3");
          heading.textContent = section[currentLanguage].title;
          sectionBlock.appendChild(heading);

          sectionQuestions.forEach((question) => {
            const counts = cloudTotals[question.id] || {};
            const total =
              question.type === "text"
                ? counts.__textCount || 0
                : Object.values(counts).reduce((sum, value) => sum + value, 0);

            const card = document.createElement("article");
            card.className = "stats-card";

            const title = document.createElement("h3");
            title.textContent = question.text?.[currentLanguage] || "";
            card.appendChild(title);

            const totalText = document.createElement("p");
            totalText.className = "stats-total";
            totalText.textContent = meta.responsesLabel(total);
            card.appendChild(totalText);

            if (!question.options || !question.options.length || question.type === "text") {
              const note = document.createElement("p");
              note.className = "stats-text-note";
              note.textContent = meta.textQuestionNote(total);
              card.appendChild(note);
            } else {
              question.options.forEach((option) => {
                const optionWrap = document.createElement("div");
                optionWrap.className = "stats-option";

                const head = document.createElement("div");
                head.className = "option-head";

                const label = document.createElement("strong");
                label.textContent = option.label?.[currentLanguage] || "";

                const detail = document.createElement("span");
                const count = counts[option.value] || 0;
                const percent = total ? Math.round((count / total) * 100) : 0;
                detail.textContent = `${count} · ${percent}%`;

                head.appendChild(label);
                head.appendChild(detail);

                const progress = document.createElement("div");
                progress.className = "progress";
                const bar = document.createElement("span");
                bar.style.width = `${percent}%`;
                progress.appendChild(bar);

                optionWrap.appendChild(head);
                optionWrap.appendChild(progress);
                card.appendChild(optionWrap);
              });
            }

            sectionBlock.appendChild(card);
          });

          ui.statsContent.appendChild(sectionBlock);
        });
      };

      const renderResponseFeedList = () => {
        if (!ui.responsesFeed || !ui.responsesEmpty) return;
        const meta = uiMeta[currentLanguage];
        ui.responsesFeed.innerHTML = "";
        if (responseFeedLoading) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesLoading;
          return;
        }
        if (responseFeedError) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesError;
          return;
        }
        if (!responseFeedItems.length) {
          ui.responsesEmpty.hidden = false;
          ui.responsesEmpty.textContent = meta.responsesEmpty;
          return;
        }
        ui.responsesEmpty.hidden = true;
        responseFeedItems.forEach((record) => {
          const entry = document.createElement("article");
          entry.className = "response-entry";

          const time = document.createElement("time");
          time.dateTime = record.submitted_at;
          time.textContent = formatTimestamp(record.submitted_at);
          entry.appendChild(time);

          const answers = record.answers && typeof record.answers === "object" ? record.answers : {};
          Object.entries(answers).forEach(([questionId, value]) => {
            const question = findQuestionById(questionId);
            if (!question) return;
            const description = describeAnswer(question, value);
            if (!description) return;

            const answerLine = document.createElement("p");
            answerLine.className = "response-answer";

            const strong = document.createElement("strong");
            strong.textContent = question.text?.[currentLanguage] || question.text?.zh || questionId;
            answerLine.appendChild(strong);
            answerLine.appendChild(document.createElement("br"));
            answerLine.appendChild(document.createTextNode(description));

            entry.appendChild(answerLine);
          });

          ui.responsesFeed.appendChild(entry);
        });
      };

      const fetchResponseFeed = async () => {
        if (!REMOTE_SYNC_ENABLED || !SUPABASE_RESPONSES_ENDPOINT) {
          throw new Error("Remote sync not configured");
        }
        const params = new URLSearchParams({
          select: "answers,submitted_at",
          order: "submitted_at.desc",
          limit: RESPONSE_FETCH_LIMIT
        });
        const requestUrl = `${SUPABASE_RESPONSES_ENDPOINT}?${params.toString()}`;
        const response = await fetch(requestUrl, { headers: supabaseAdminHeaders || {} });
        if (!response.ok) {
          throw new Error(`Failed to load response feed: ${response.status}`);
        }
        return response.json();
      };

      const loadResponseFeed = async () => {
        if (!REMOTE_SYNC_ENABLED) {
          responseFeedItems = [];
          responseFeedError = null;
          responseFeedLoading = false;
          renderResponseFeedList();
          return;
        }
        if (responseFeedLoading) return;
        responseFeedLoading = true;
        responseFeedError = null;
        renderResponseFeedList();
        try {
          const records = await fetchResponseFeed();
          responseFeedItems = Array.isArray(records)
            ? records.map((item) => ({
                submitted_at: item.submitted_at,
                answers: item.answers
              }))
            : [];
        } catch (error) {
          responseFeedError = error;
        } finally {
          responseFeedLoading = false;
          renderResponseFeedList();
        }
      };

      const switchScreen = (target) => {
        if (!ui.builderView || !ui.statsView) return;
        if (target === currentScreen) {
          if (target === "stats") {
            renderStats();
            loadCloudStats();
            loadResponseFeed();
          }
          return;
        }
        currentScreen = target;
        const showBuilder = target === "builder";
        ui.builderView.hidden = !showBuilder;
        ui.statsView.hidden = showBuilder;
        if (ui.builderTab) {
          ui.builderTab.classList.toggle("active", showBuilder);
        }
        if (ui.statsTab) {
          ui.statsTab.classList.toggle("active", !showBuilder);
        }
        if (!showBuilder) {
          renderStats();
          loadCloudStats();
          loadResponseFeed();
        }
      };

      const renderCopyEditor = () => {
        const meta = uiMeta[currentLanguage];
        const copy = contentText[currentLanguage];
        copyEditor.innerHTML = "";

        const head = document.createElement("div");
        head.className = "copy-head";
        const eyebrow = document.createElement("p");
        eyebrow.className = "eyebrow";
        eyebrow.textContent = meta.copyLabel;
        const heading = document.createElement("h3");
        heading.textContent = meta.copyTitle;
        head.appendChild(eyebrow);
        head.appendChild(heading);
        copyEditor.appendChild(head);

        const helper = document.createElement("p");
        helper.className = "copy-helper";
        helper.textContent = meta.copyHelper;
        copyEditor.appendChild(helper);

        const grid = document.createElement("div");
        grid.className = "copy-grid";

        copyFieldConfig.forEach((field) => {
          const wrapper = document.createElement("label");
          wrapper.className = "copy-field";

          const span = document.createElement("span");
          span.textContent = meta.copyFieldLabels[field.id];

          const control =
            field.type === "textarea" ? document.createElement("textarea") : document.createElement("input");
          if (field.type !== "textarea") {
            control.type = "text";
          }
          control.value = copy[field.id] || "";
          control.addEventListener("input", (event) => {
            contentText[currentLanguage][field.id] = event.target.value;
            updateUIText();
          });

          wrapper.appendChild(span);
          wrapper.appendChild(control);
          grid.appendChild(wrapper);
        });

        copyEditor.appendChild(grid);
      };

      const handleSubmit = async () => {
        if (!questionList) return;
        if (!questionList.reportValidity()) {
          return;
        }

        const meta = uiMeta[currentLanguage];
        const formData = new FormData(questionList);
        const submissionPayload = {};
        let hasMissing = false;
        let firstInvalidQuestion = null;

        const markMissing = (question) => {
          if (!hasMissing) {
            firstInvalidQuestion = question.id;
          }
          hasMissing = true;
        };

        questions.forEach((question) => {
          if (question.type === "single") {
            const selectedValue = formData.get(question.id);
            if (!selectedValue) {
              markMissing(question);
              return;
            }
            const option = findOptionByValue(question, selectedValue.toString());
            if (!option) {
              markMissing(question);
              return;
            }
            const entry = { type: "single", selection: selectedValue.toString() };
            if (option.hasTextInput) {
              const extraValue = (formData.get(`${question.id}__${option.value}__text`) || "").toString().trim();
              if (!extraValue) {
                markMissing(question);
                return;
              }
              entry.otherText = extraValue;
            }
            submissionPayload[question.id] = entry;
          } else if (question.type === "multi") {
            const selections = formData.getAll(question.id).map((value) => value.toString());
            if (!selections.length) {
              markMissing(question);
              return;
            }
            const entry = { type: "multi", selections };
            const otherText = {};
            selections.forEach((selected) => {
              const option = findOptionByValue(question, selected);
              if (option?.hasTextInput) {
                const extraValue = (formData.get(`${question.id}__${option.value}__text`) || "").toString().trim();
                if (!extraValue) {
                  markMissing(question);
                } else {
                  otherText[selected] = extraValue;
                }
              }
            });
            if (hasMissing) {
              return;
            }
            if (Object.keys(otherText).length) {
              entry.otherText = otherText;
            }
            submissionPayload[question.id] = entry;
        } else if (question.type === "text") {
          const textValue = (formData.get(question.id) || "").toString().trim();
          if (!textValue) {
            if (question.required) {
              markMissing(question);
            }
            return;
          }
          submissionPayload[question.id] = { type: "text", text: textValue };
        }
      });

        if (hasMissing) {
          if (firstInvalidQuestion) {
            const target = questionList.querySelector(`[data-question-id="${firstInvalidQuestion}"]`);
            target?.scrollIntoView({ behavior: "smooth", block: "center" });
          }
          alert(meta.requiredError);
          return;
        }

        questionList.reset();
        renderPreview();
        alert(meta.submitSuccess);
        switchScreen("stats");
        saveResponseSubmission(submissionPayload).then(() => {
          loadCloudStats();
          loadResponseFeed();
        });
      };

      const updateUIText = () => {
        const copy = contentText[currentLanguage];
        const meta = uiMeta[currentLanguage];
        setText(ui.heroEyebrow, copy.heroEyebrow);
        setText(ui.heroTitle, copy.heroTitle);
        setText(ui.heroDesc, copy.heroDesc);
        setText(ui.previewLabel, copy.previewLabel);
        setText(ui.previewTitle, copy.previewTitle);
        setText(ui.editorLabel, copy.editorLabel);
        setText(ui.editorTitle, copy.editorTitle);
        setText(ui.scrollDownLabel, copy.scrollDown);
        setText(ui.addQuestion, copy.addQuestion);
        setText(ui.submit, copy.submit);
        setText(ui.langToggle, meta.toggle);
        setText(ui.logoLabel, meta.logoLabel);
        setText(ui.logoTitle, meta.logoTitle);
        setText(ui.logoHelper, meta.logoHelper);
        setText(ui.logoUploadText, meta.logoUpload);
        setText(ui.logoResetButton, meta.logoReset);
        setText(ui.qrLabel, meta.qrLabel);
        setText(ui.qrTitle, meta.qrTitle);
        setText(ui.qrHelper, meta.qrHelper);
        setText(ui.qrInputLabel, meta.qrInputLabel);
        setText(ui.qrRefresh, meta.qrRefresh);
        setText(ui.qrNote, meta.qrNote);
        setText(ui.adminButton, meta.adminButton);
        setText(ui.exitAdminButton, meta.exitAdminButton || "");
        setText(ui.saveButton, meta.saveChanges || "");
        setText(ui.builderTab, meta.tabBuilder);
        setText(ui.statsTab, meta.tabStats);
        setText(ui.statsLabel, meta.statsLabel);
        setText(ui.statsTitle, meta.statsTitle);
        setText(ui.statsHelper, meta.statsHelper);
        setText(ui.statsEmpty, meta.statsEmpty);
        setText(ui.responsesLabel, meta.responsesPanelLabel);
        setText(ui.responsesTitle, meta.responsesPanelTitle);
        setText(ui.responsesHelper, meta.responsesHelper);
        setText(ui.responseRefresh, meta.responsesRefresh);
        if (!responseFeedItems.length && !responseFeedLoading) {
          setText(ui.responsesEmpty, meta.responsesEmpty);
        }
        renderStats();
        renderResponseFeedList();
      };

      const loadCloudStats = async () => {
        if (!adminEnabled) {
          statsLoading = false;
          renderStats();
          return;
        }
        statsLoading = true;
        statsError = null;
        renderStats();
        if (!REMOTE_SYNC_ENABLED || !SUPABASE_RESPONSES_ENDPOINT) {
          statsLoading = false;
          renderStats();
          return;
        }
        try {
          const params = new URLSearchParams({
            select: "answers,submitted_at",
            order: "submitted_at.desc",
            limit: STATS_FETCH_LIMIT.toString()
          });
          const response = await fetch(`${SUPABASE_RESPONSES_ENDPOINT}?${params.toString()}`, {
            headers: supabaseAdminHeaders || {}
          });
          if (!response.ok) {
            throw new Error(`Failed to load cloud stats (${response.status})`);
          }
          const data = await response.json();
          const records = Array.isArray(data) ? data : [];
          cloudTotals = aggregateCloudTotals(records);
          cloudSubmissionCount = records.length;
          cloudLastUpdated = records[0]?.submitted_at || null;
        } catch (error) {
          statsError = error;
        } finally {
          statsLoading = false;
          renderStats();
        }
      };

      if (ui.addQuestion) {
        ui.addQuestion.addEventListener("click", () => {
          const count = questions.length + 1;
          const newId = createId();
          const newQuestion = {
            id: newId,
            sectionId: questionSections[0].id,
            type: "single",
            required: true,
            text: {
              zh: `新问题 ${count}`,
              en: `New question ${count}`
            },
            description: {
              zh: "",
              en: ""
            },
            options: [
              { value: "option-a", label: { zh: "选项 1", en: "Option 1" } },
              { value: "option-b", label: { zh: "选项 2", en: "Option 2" } },
              { value: "option-c", label: { zh: "选项 3", en: "Option 3" } }
            ]
          };
          questions.push(newQuestion);
          renderEditor();
          renderPreview();
          renderStats();
        });
      }

      ui.langToggle.addEventListener("click", () => {
        currentLanguage = currentLanguage === "zh" ? "en" : "zh";
        document.documentElement.lang = currentLanguage === "zh" ? "zh-CN" : "en";
        renderCopyEditor();
        renderEditor();
        renderPreview();
        updateUIText();
      });

      if (ui.builderTab) {
        ui.builderTab.addEventListener("click", () => switchScreen("builder"));
      }

      if (ui.statsTab) {
        ui.statsTab.addEventListener("click", () => switchScreen("stats"));
      }

      if (ui.responseRefresh) {
        ui.responseRefresh.addEventListener("click", () => {
          loadResponseFeed();
        });
      }

      if (ui.submit) {
        ui.submit.addEventListener("click", handleSubmit);
      }

      if (ui.adminButton) {
        ui.adminButton.addEventListener("click", () => {
          const meta = uiMeta[currentLanguage];
          if (!ADMIN_PASSWORD) {
            alert(currentLanguage === "zh" ? "管理员密码未配置，请联系维护者。" : "Admin password is not configured.");
            return;
          }
          const input = window.prompt(meta.adminPrompt);
          if (input === null) return;
          if (input.trim() === ADMIN_PASSWORD) {
            enableAdminMode();
          } else {
            alert(meta.adminError);
          }
        });
      }

      if (ui.exitAdminButton) {
        ui.exitAdminButton.addEventListener("click", () => {
          disableAdminMode();
        });
      }

      if (ui.saveButton) {
        ui.saveButton.addEventListener("click", async () => {
          const meta = uiMeta[currentLanguage];
          persistQuestions();
          persistContent();
          if (!REMOTE_SYNC_ENABLED) {
            alert(currentLanguage === "zh" ? "已保存到本地，未配置云端同步。" : "Saved locally. Cloud sync is not configured.");
            return;
          }
          ui.saveButton.disabled = true;
          try {
            await saveRemoteConfig({
              questions,
              contentText,
              logoDataUrl: currentLogoDataUrl,
              qrUrl:
                (currentQrUrl && isValidUrl(currentQrUrl) && currentQrUrl) ||
                (loadStoredQrUrl() && isValidUrl(loadStoredQrUrl()) && loadStoredQrUrl()) ||
                DEFAULT_QR_URL ||
                window.location.href
            });
            alert(meta.saveSuccess || "已保存");
          } catch (error) {
            alert(currentLanguage === "zh" ? "保存失败，请稍后再试。" : "Failed to save. Please try again.");
          } finally {
            ui.saveButton.disabled = false;
          }
        });
      }

      if (ui.qrRefresh) {
        ui.qrRefresh.addEventListener("click", updateQrFromInput);
      }

      if (ui.qrUrlInput) {
        ui.qrUrlInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            updateQrFromInput();
          }
        });
      }

      if (ui.logoInput) {
        ui.logoInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          if (file.size > LOGO_MAX_BYTES) {
            alert(currentLanguage === "zh" ? "请选择 2 MB 以下的图片文件。" : "Please choose an image smaller than 2 MB.");
            event.target.value = "";
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = reader.result;
            if (typeof dataUrl === "string") {
              currentLogoDataUrl = dataUrl;
              applyLogoSrc(dataUrl);
              persistLogo(dataUrl);
            }
          };
          reader.onerror = () => {
            alert(currentLanguage === "zh" ? "无法读取文件，请重试。" : "Unable to read the file. Please try again.");
          };
          reader.readAsDataURL(file);
        });
      }

      if (ui.logoResetButton) {
        ui.logoResetButton.addEventListener("click", () => {
          persistLogo(null);
          currentLogoDataUrl = null;
          applyLogoSrc(DEFAULT_LOGO_SRC);
          if (ui.logoInput) {
            ui.logoInput.value = "";
          }
        });
      }

      if (ui.scrollRange && editorList) {
        ui.scrollRange.addEventListener("input", (event) => {
          const maxScroll = editorList.scrollHeight - editorList.clientHeight;
          if (maxScroll <= 0) return;
          const ratio = Number(event.target.value) / 100;
          editorList.scrollTop = ratio * maxScroll;
        });
      }

      if (editorList) {
        editorList.addEventListener("scroll", syncScrollHandle);
        window.addEventListener("resize", syncScrollHandle);
      }

      const bootstrap = async () => {
        let syncedLogo = false;
        try {
          const remoteConfig = await fetchRemoteConfig();
          if (remoteConfig) {
            if (isValidQuestionSet(remoteConfig.questions)) {
              questions = remoteConfig.questions;
              persistQuestions();
            }
            if (remoteConfig.contentText) {
              contentText = remoteConfig.contentText;
              persistContent();
            }
            if (remoteConfig.logoDataUrl) {
              currentLogoDataUrl = remoteConfig.logoDataUrl;
              applyLogoSrc(currentLogoDataUrl);
              persistLogo(currentLogoDataUrl);
              syncedLogo = true;
            }
            if (remoteConfig.qrUrl && isValidUrl(remoteConfig.qrUrl)) {
              currentQrUrl = remoteConfig.qrUrl;
              persistQrUrl(remoteConfig.qrUrl);
              if (ui.qrUrlInput) {
                ui.qrUrlInput.value = remoteConfig.qrUrl;
              }
              if (ui.qrCode) {
                renderQrCode(remoteConfig.qrUrl);
              }
            }
          }
        } catch (error) {
          console.warn("Unable to load remote config, falling back to local cache");
        }

        if (!syncedLogo) {
          loadStoredLogo();
        }

        initQrSection();

        const resumeAdmin = ADMIN_PASSWORD && sessionStorage.getItem(ADMIN_MODE_KEY) === "true";
        if (resumeAdmin) {
          enableAdminMode();
        } else {
          disableAdminMode();
        }

        renderPreview();
        renderEditor();
        renderCopyEditor();
        renderStats();
        loadCloudStats();
        loadResponseFeed();
        updateUIText();
        setQrEditable(adminEnabled);
        setStatsVisibility(adminEnabled);
      };

      bootstrap();
    </script>
  </body>
</html>
